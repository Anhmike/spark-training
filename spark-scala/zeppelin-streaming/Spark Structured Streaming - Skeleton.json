{"paragraphs":[{"text":"%md\n# 0. Add Dependencies\n\nBefore we start working with Spark and Kafka, we need to add the Spark Kafka SQL dependency to Zeppelin:\n```\norg.apache.spark:spark-sql-kafka-0-10_2.11:2.3.0 exclude: net.jpountz.lz4:lz4\n```","user":"anonymous","dateUpdated":"2018-06-05T06:43:08+0000","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180983118_546533281","id":"20180605-064303_775078356","dateCreated":"2018-06-05T06:43:03+0000","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:3707","dateFinished":"2018-06-05T06:43:06+0000","dateStarted":"2018-06-05T06:43:06+0000","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>0. Add Dependencies</h1>\n<p>Before we start working with Spark and Kafka, we need to add the Spark Kafka SQL dependency to Zeppelin:</p>\n<pre><code>org.apache.spark:spark-sql-kafka-0-10_2.11:2.3.0 exclude: net.jpountz.lz4:lz4\n</code></pre>\n"}]}},{"text":"%md\n# 1. Create Kafka Producer\n\nWe want to fill a Kafka topic with some data, for example we can fill Alice in Wonderland to a topic\n\n    s3cat.py -T -I1 -B10 s3://dimajix-training/data/alice/alice-in-wonderland.txt | /opt/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic alice\n","dateUpdated":"2018-06-05T06:43:23+0000","config":{"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"tableHide":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>1. Create Kafka Producer</h1>\n<p>We want to fill a Kafka topic with some data, for example we can fill Alice in Wonderland to a topic</p>\n<pre><code>s3cat.py -T -I1 -B10 s3://dimajix-training/data/alice/alice-in-wonderland.txt | /opt/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic alice\n</code></pre>\n"}]},"apps":[],"jobName":"paragraph_1528180009325_-2135978734","id":"20170218-160028_195174762","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:2054","user":"anonymous","dateFinished":"2018-06-05T06:43:23+0000","dateStarted":"2018-06-05T06:43:23+0000"},{"text":"%md\n# 2. Connect to Data Source\n\nNow that we have a Kafka producer up and running, we can connect to Kafka with Spark. We connect to the Kafka topic as the datasource by using the `DataStreamReader` API via `spark.readStream`. We need to specify the options `kafka.bootstrap.servers` and `subscribe` and we need to use the format `kafka` for connecting to the data source. The topic will stream data samples in raw format, i.e. one record per line.","user":"anonymous","dateUpdated":"2018-06-05T06:44:29+0000","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","editorHide":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528181063509_-1417938763","id":"20180605-064423_760896823","dateCreated":"2018-06-05T06:44:23+0000","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:3810","dateFinished":"2018-06-05T06:44:26+0000","dateStarted":"2018-06-05T06:44:26+0000","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>2. Connect to Data Source</h1>\n<p>Now that we have a Kafka producer up and running, we can connect to Kafka with Spark. We connect to the Kafka topic as the datasource by using the <code>DataStreamReader</code> API via <code>spark.readStream</code>. We need to specify the options <code>kafka.bootstrap.servers</code> and <code>subscribe</code> and we need to use the format <code>kafka</code> for connecting to the data source. The topic will stream data samples in raw format, i.e. one record per line.</p>\n"}]}},{"text":"// Fill in the correct AWS VPC address of your master host\nval master = \"kku.training.dimajix-aws.net\"\n\n// Connect to raw text stream socket using the DataStreamReader API via spark.readStream. You need to specify the options `kafka.bootstrap.servers`, `subscribe` and you need to use the format `kafka`\nval lines = ...","dateUpdated":"2018-06-05T06:44:13+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009326_-2134824487","id":"20170218-160002_129671727","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2055"},{"text":"%md\n## 2.1 Inspect Schema\n\nThe result of the load method is a `DataFrame` again, but a streaming one. This `DataFrame` again has a schema, which we can inspect with the usual method:","dateUpdated":"2018-06-05T06:44:43+0000","config":{"colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>2.1 Inspect Schema</h2>\n<p>The result of the load method is a <code>DataFrame</code> again, but a streaming one. This <code>DataFrame</code> again has a schema, which we can inspect with the usual method:</p>\n"}]},"apps":[],"jobName":"paragraph_1528180009326_-2134824487","id":"20170218-161504_128762750","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2056","user":"anonymous","dateFinished":"2018-06-05T06:44:35+0000","dateStarted":"2018-06-05T06:44:35+0000"},{"text":"lines.printSchema()","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009326_-2134824487","id":"20170218-160206_920542952","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2057"},{"text":"%md\n## 2.2 Extract Timestamp\n\nThis time a timestamp is attached to every line. We want to extract the timestamp and handle it separately.","dateUpdated":"2018-06-05T06:46:50+0000","config":{"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"tableHide":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>2.2 Extract Timestamp</h2>\n<p>This time a timestamp is attached to every line. We want to extract the timestamp and handle it separately.</p>\n"}]},"apps":[],"jobName":"paragraph_1528180009327_-2135209236","id":"20170218-165528_130307776","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2058","user":"anonymous","dateFinished":"2018-06-05T06:46:50+0000","dateStarted":"2018-06-05T06:46:50+0000"},{"text":"import org.apache.spark.sql.types.TimestampType\n\nval ts_lines = ...","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009327_-2135209236","id":"20170218-165525_1370327040","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2059"},{"text":"ts_lines.printSchema","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009327_-2135209236","id":"20170218-165602_1908375523","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2060"},{"text":"%md\n# 3. Inspect Data\n\nOf course we also want to inspect the data inside the DataFrame. But this time, we cannot simply invoke `show`, because normal actions do not (directly) work on streaming DataFrames. Instead we need to create a continiuous query. Later, we will see a neat trick how a streaming query can be transformed into a volatile table.\n\nIn order to create a continuous query, we need to perform the following steps\n\n1. Create a `DataStreamWriter` by using the `writeStream` method of a DataFrame\n2. Specify the output format. We use `console` in our case\n3. Specify a checkpoint location on HDFS. This is required for restarting\n4. Optionally specify a processing period\n5. Start the query\n6. For Zeppelin only: Sleep a little bit, or we miss the output","dateUpdated":"2018-06-05T06:47:03+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>3. Inspect Data</h1>\n<p>Of course we also want to inspect the data inside the DataFrame. But this time, we cannot simply invoke <code>show</code>, because normal actions do not (directly) work on streaming DataFrames. Instead we need to create a continiuous query. Later, we will see a neat trick how a streaming query can be transformed into a volatile table.</p>\n<p>In order to create a continuous query, we need to perform the following steps</p>\n<ol>\n<li>Create a <code>DataStreamWriter</code> by using the <code>writeStream</code> method of a DataFrame</li>\n<li>Specify the output format. We use <code>console</code> in our case</li>\n<li>Specify a checkpoint location on HDFS. This is required for restarting</li>\n<li>Optionally specify a processing period</li>\n<li>Start the query</li>\n<li>For Zeppelin only: Sleep a little bit, or we miss the output</li>\n</ol>\n"}]},"apps":[],"jobName":"paragraph_1528180009327_-2135209236","id":"20170218-161603_528321172","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2061","user":"anonymous","dateFinished":"2018-06-05T06:47:03+0000","dateStarted":"2018-06-05T06:47:03+0000"},{"text":"val query = ...","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009328_-2124821016","id":"20170218-160132_1015574950","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2062"},{"text":"%md\n## 3.1 Stop Query\n\nIn contrast to the RDD API, we can simply stop an individual query instead of a whole StreamingContext by simply calling the `stop` method on the query object. This makes working with streams much easier.","dateUpdated":"2018-06-05T06:47:09+0000","config":{"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"tableHide":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>3.1 Stop Query</h2>\n<p>In contrast to the RDD API, we can simply stop an individual query instead of a whole StreamingContext by simply calling the <code>stop</code> method on the query object. This makes working with streams much easier.</p>\n"}]},"apps":[],"jobName":"paragraph_1528180009328_-2124821016","id":"20170218-161746_736484246","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2063","user":"anonymous","dateFinished":"2018-06-05T06:47:09+0000","dateStarted":"2018-06-05T06:47:09+0000"},{"text":"","dateUpdated":"2018-06-05T06:26:49+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1528180009328_-2124821016","id":"20170218-160155_661067655","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2064"},{"text":"%md\n# 4. Counting Words\n\nSo we now want to create a streaming word count. We perform the same actions as in the traditional DataFrame word count example, i.e. we split every line into words, group the words and count the sizes of the groups.","dateUpdated":"2018-06-05T06:47:14+0000","config":{"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"tableHide":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>4. Counting Words</h1>\n<p>So we now want to create a streaming word count. We perform the same actions as in the traditional DataFrame word count example, i.e. we split every line into words, group the words and count the sizes of the groups.</p>\n"}]},"apps":[],"jobName":"paragraph_1528180009328_-2124821016","id":"20170218-161837_1521722724","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2065","user":"anonymous","dateFinished":"2018-06-05T06:47:14+0000","dateStarted":"2018-06-05T06:47:14+0000"},{"text":"val words = ...","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009329_-2125205764","id":"20170218-160238_1475524112","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2066"},{"text":"val counts = ...","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009329_-2125205764","id":"20170218-160526_2008806660","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2067"},{"text":"","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009329_-2125205764","id":"20170218-162308_1835168589","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2068"},{"text":"%md\n## 4.1 Print Results onto Console\n\nAgain we want to print the results onto the console.","dateUpdated":"2018-06-05T06:47:20+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>4.1 Print Results onto Console</h2>\n<p>Again we want to print the results onto the console.</p>\n"}]},"apps":[],"jobName":"paragraph_1528180009329_-2125205764","id":"20170218-161041_735302634","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2069","user":"anonymous","dateFinished":"2018-06-05T06:47:20+0000","dateStarted":"2018-06-05T06:47:20+0000"},{"text":"val query = ...","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009330_-2124051518","id":"20170218-160613_988660270","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2070"},{"text":"","dateUpdated":"2018-06-05T06:26:49+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1528180009330_-2124051518","id":"20170218-160716_194527039","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2071"},{"text":"%md\n# 5. Time-Windowed Aggregation\n\nAnother interesting (and probably more realistic) application is to perform time windowed aggregations. This means that we define a sliding time window used in the `groupBy` clause. In addition we also define a so called *watermark* which tells Spark how long to wait for late arrivels of individual data points (we don't have them in our simple example).","dateUpdated":"2018-06-05T06:47:27+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h1>5. Time-Windowed Aggregation</h1>\n<p>Another interesting (and probably more realistic) application is to perform time windowed aggregations. This means that we define a sliding time window used in the <code>groupBy</code> clause. In addition we also define a so called <em>watermark</em> which tells Spark how long to wait for late arrivels of individual data points (we don't have them in our simple example).</p>\n"}]},"apps":[],"jobName":"paragraph_1528180009330_-2124051518","id":"20170218-164639_1471935006","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2072","user":"anonymous","dateFinished":"2018-06-05T06:47:27+0000","dateStarted":"2018-06-05T06:47:27+0000"},{"text":"val windowedCounts = ...","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009331_-2124436267","id":"20170218-164703_2039341008","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2073"},{"text":"","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009331_-2124436267","id":"20170218-165357_1483843188","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2074"},{"text":"%md\n## 5.1 Create Dynamic Table\n\nWe can also use a \"memory\" output, which is a queryable live table. In order to do so, we again create a new table, but this time with format `memory` and an explicit query name `aggregated_weather`. Using a `memory` output will create a dynamic table in memory (only `complete` output supported right now), which can be queried using SQL.\n\n1. Create a DataStreamWriter object using the writeStream method of your DataFrame `windowedCounts`.\n2. Set the format to `memory`\n3. Set the output mode to `append` (this is supported for time windowed aggregations)\n4. Set the query name to `alice_counts`\n5. Specify a checkPointLocation on HDFS (ok, this is not trivial, so it is in the code below)\n6. Start the continuous query via `start`","dateUpdated":"2018-06-05T06:47:33+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>5.1 Create Dynamic Table</h2>\n<p>We can also use a &ldquo;memory&rdquo; output, which is a queryable live table. In order to do so, we again create a new table, but this time with format <code>memory</code> and an explicit query name <code>aggregated_weather</code>. Using a <code>memory</code> output will create a dynamic table in memory (only <code>complete</code> output supported right now), which can be queried using SQL.</p>\n<ol>\n<li>Create a DataStreamWriter object using the writeStream method of your DataFrame <code>windowedCounts</code>.</li>\n<li>Set the format to <code>memory</code></li>\n<li>Set the output mode to <code>append</code> (this is supported for time windowed aggregations)</li>\n<li>Set the query name to <code>alice_counts</code></li>\n<li>Specify a checkPointLocation on HDFS (ok, this is not trivial, so it is in the code below)</li>\n<li>Start the continuous query via <code>start</code></li>\n</ol>\n"}]},"apps":[],"jobName":"paragraph_1528180009331_-2124436267","id":"20170218-160934_1425298948","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2075","user":"anonymous","dateFinished":"2018-06-05T06:47:33+0000","dateStarted":"2018-06-05T06:47:33+0000"},{"text":"val tableQuery = ...","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009331_-2124436267","id":"20170218-161145_208429016","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2076"},{"text":"%md\n## 5.2 Perform Query\n\nNow that we have a dynamic table, we can perform SQL queries against this table as if it was a normal static table.","dateUpdated":"2018-06-05T06:47:39+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>5.2 Perform Query</h2>\n<p>Now that we have a dynamic table, we can perform SQL queries against this table as if it was a normal static table.</p>\n"}]},"apps":[],"jobName":"paragraph_1528180009332_-2126360011","id":"20170218-162010_1110788275","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2077","user":"anonymous","dateFinished":"2018-06-05T06:47:39+0000","dateStarted":"2018-06-05T06:47:39+0000"},{"text":"%sql\n","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"sql","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/sql","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[{"name":"window","index":0,"aggr":"sum"}],"values":[{"name":"word","index":1,"aggr":"sum"}],"groups":[],"scatter":{"xAxis":{"name":"window","index":0,"aggr":"sum"},"yAxis":{"name":"word","index":1,"aggr":"sum"}}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009332_-2126360011","id":"20170218-161337_1103351127","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2078"},{"text":"%md\n## 5.3 Stop Query\n\nIn order to clean everything up, we stop the query again.","dateUpdated":"2018-06-05T06:47:46+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>5.3 Stop Query</h2>\n<p>In order to clean everything up, we stop the query again.</p>\n"}]},"apps":[],"jobName":"paragraph_1528180009332_-2126360011","id":"20170218-162048_842521010","dateCreated":"2018-06-05T06:26:49+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:2079","user":"anonymous","dateFinished":"2018-06-05T06:47:46+0000","dateStarted":"2018-06-05T06:47:46+0000"},{"text":"","dateUpdated":"2018-06-05T06:26:49+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1528180009332_-2126360011","id":"20170218-161329_1844676678","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2080"},{"text":"","dateUpdated":"2018-06-05T06:26:49+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1528180009333_-2126744760","id":"20170218-162247_324928954","dateCreated":"2018-06-05T06:26:49+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:2081"}],"name":"Spark Structured Streaming - Skeleton","id":"2DEK3WQVY","angularObjects":{"2BRWU4WXC:shared_process":[],"2AM1YV5CU:shared_process":[],"2AJXGMUUJ:shared_process":[],"2ANGGHHMQ:shared_process":[],"2AKK3QQXU:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}