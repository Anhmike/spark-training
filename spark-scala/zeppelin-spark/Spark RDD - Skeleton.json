{"paragraphs":[{"text":"%md\n# 1 Creating RDDs\n\nAs the first step we always need some way to generate an RDD. In the following examples, we discuss some methods for creatign RDDs from local Scala collections. This is not the normal use case, but can come in handy not only in trainings.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692652_702623607","id":"20160608-202711_364435625","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>1 Creating RDDs</h1>\n<p>As the first step we always need some way to generate an RDD. In the following examples, we discuss some methods for creatign RDDs from local Scala collections. This is not the normal use case, but can come in handy not only in trainings.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:13079"},{"text":"%md\n## 1.1 Creating RDDs from Scala Collections\n\nThe simplest thing is to create a Spark RDD from a Scala collection. Spark can store any object in an RDD as long as it can be serialized. The simplest example uses numbers","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692653_702238858","id":"20181110-134942_669022169","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>1.1 Creating RDDs from Scala Collections</h2>\n<p>The simplest thing is to create a Spark RDD from a Scala collection. Spark can store any object in an RDD as long as it can be serialized. The simplest example uses numbers</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13080"},{"text":"// YOUR CODE HERE","dateUpdated":"2018-11-14T19:13:22+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692654_703393104","id":"20160608-202711_1542689802","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13081"},{"text":"%md\nOf course we can also use strings as objects","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692654_703393104","id":"20181110-135040_263615688","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<p>Of course we can also use strings as objects</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13082"},{"text":"val rdd = // YOUR CODE HERE\nprint(rdd.collect().mkString(\",\"))","dateUpdated":"2018-11-14T19:13:22+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692654_703393104","id":"20181110-135124_2112920349","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13083"},{"text":"%md\n### Creating RDDs from Iterables\nIt is even possible to create an RDD from an Scala iterable object, like a range.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692655_703008356","id":"20181110-135105_2137348480","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3>Creating RDDs from Iterables</h3>\n<p>It is even possible to create an RDD from an Scala iterable object, like a range.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13084"},{"text":"val rdd = // YOUR CODE HERE\nprint(rdd.collect().mkString(\",\"))","dateUpdated":"2018-11-14T19:13:22+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692655_703008356","id":"20160608-202711_1417431983","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13085"},{"text":"%md\n### Creating a range RDD\nSpark also directly supports creating a range RDD as follows","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692655_703008356","id":"20181110-135152_1785240713","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3>Creating a range RDD</h3>\n<p>Spark also directly supports creating a range RDD as follows</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13086"},{"text":"val rdd = sc.range(1,31,3)\nprint(rdd.collect().mkString(\",\"))","dateUpdated":"2018-11-14T19:11:32+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692656_713396576","id":"20160617-161025_1250626577","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13087"},{"text":"%md\n## 1.1 Loading Data from S3/HDFS\n\nOf course normally you'd want to read data from some storage (HDFS or S3 for example). Spark supports various very simple file formats (text files, Hadoop Sequence files), but not structured formats like CSV or parquet. Tabular formats are supported in the Spark DataFrame API, but the RDD API can only handle simple serialization formats.\n\nWe will use a text file as an example.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692656_713396576","id":"20160608-202711_1905251818","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>1.1 Loading Data from S3/HDFS</h2>\n<p>Of course normally you&rsquo;d want to read data from some storage (HDFS or S3 for example). Spark supports various very simple file formats (text files, Hadoop Sequence files), but not structured formats like CSV or parquet. Tabular formats are supported in the Spark DataFrame API, but the RDD API can only handle simple serialization formats.</p>\n<p>We will use a text file as an example.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13088"},{"text":"val alice = // YOUR CODE HERE\n\nalice.take(10).foreach(println)","dateUpdated":"2018-11-14T19:13:23+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692656_713396576","id":"20160608-202711_438644709","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13089"},{"text":"%md \n## 1.2 Retrieving Data\n\nNow that we have an RDD (which is distributed in the cluster), we also want to have a method for retrieving all records back to the local machine where the Spark driver runs. This can be done via the `collect()` method.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692657_713011827","id":"20160608-202711_2137747659","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>1.2 Retrieving Data</h2>\n<p>Now that we have an RDD (which is distributed in the cluster), we also want to have a method for retrieving all records back to the local machine where the Spark driver runs. This can be done via the <code>collect()</code> method.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13090"},{"text":"val numbers = sc.parallelize(1 to 100)\nval localData = // YOUR CODE HERE\n","dateUpdated":"2018-11-14T19:13:23+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692657_713011827","id":"20160608-202711_1723490503","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13091"},{"text":"%md\n### First record\n\nSince an RDD could contain a huge amount of data, using `collect()` is highly discouraged except in situations where you really know that the number of records is limited. But nevertheless it is quire useful (specifically in interactive environments like Zeppelin) to peek inside an RDD.\n\nUsing the `first()` method allows us to retrieve the very first record.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692657_713011827","id":"20181110-135548_1848397879","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3>First record</h3>\n<p>Since an RDD could contain a huge amount of data, using <code>collect()</code> is highly discouraged except in situations where you really know that the number of records is limited. But nevertheless it is quire useful (specifically in interactive environments like Zeppelin) to peek inside an RDD.</p>\n<p>Using the <code>first()</code> method allows us to retrieve the very first record.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13092"},{"text":"val localData = // YOUR CODE HERE\n\nprint(localData)","dateUpdated":"2018-11-14T19:14:27+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692658_714166074","id":"20160608-202711_1445453185","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13093"},{"text":"%md\n### First n records\n\nUsing the `take(n)` method you can also retrieve the first `n` records from an RDD.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692658_714166074","id":"20181110-135730_1377630540","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3>First n records</h3>\n<p>Using the <code>take(n)</code> method you can also retrieve the first <code>n</code> records from an RDD.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13094"},{"text":"val localData = // YOUR CODE HERE\n\nprint(localData.mkString(\",\"))","dateUpdated":"2018-11-14T19:14:27+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692658_714166074","id":"20160608-202711_1396665431","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13095"},{"text":"%md\n### Sampling n records\nIn addition to taking top `n` records, Spark also supports *sampling* records, which will retrieve a (hopefully) representative subset of the data.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692659_713781325","id":"20181110-135923_975091599","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3>Sampling n records</h3>\n<p>In addition to taking top <code>n</code> records, Spark also supports <em>sampling</em> records, which will retrieve a (hopefully) representative subset of the data.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13096"},{"text":"val localData = // YOUR CODE HERE\n\nprint(localData.mkString(\",\"))","dateUpdated":"2018-11-14T19:14:27+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692659_713781325","id":"20160612-120518_1545543070","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13097"},{"text":"%md\n# 2 Simple Transformations\n\nSpark RDDs try to closely mimic the Scala collection API (where it makes sense). The simplest type of transformation of a Scala collection is a `map` operation. A Spark RDD also provides exactly that operation.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692659_713781325","id":"20160608-202711_1759637107","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>2 Simple Transformations</h1>\n<p>Spark RDDs try to closely mimic the Scala collection API (where it makes sense). The simplest type of transformation of a Scala collection is a <code>map</code> operation. A Spark RDD also provides exactly that operation.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13098"},{"text":"val result = // YOUR CODE HERE\n\nprint(result.collect.mkString(\",\"))","dateUpdated":"2018-11-14T19:14:27+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692660_711857580","id":"20160608-202711_1223554512","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13099"},{"text":"val result = // YOUR CODE HERE\nval words = // YOUR CODE HERE\n\nwords.foreach(x => println(x.mkString(\",\")))","dateUpdated":"2018-11-14T19:14:27+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692660_711857580","id":"20160608-202711_2124763159","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13100"},{"text":"%md\n### `flatMap` transformations\n\nOf course Spark also provides a `flatMap` operation, which will flatten results of the provided function.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692660_711857580","id":"20181110-140258_1042389775","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3><code>flatMap</code> transformations</h3>\n<p>Of course Spark also provides a <code>flatMap</code> operation, which will flatten results of the provided function.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13101"},{"text":"val result = // YOUR CODE HERE\nval words = result.take(20)\n\nwords.foreach(println)","dateUpdated":"2018-11-14T19:14:28+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692661_711472831","id":"20160608-202711_388847350","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13102"},{"text":"%md\n# 3 Filtering Data\n\nThe next complex operation is filtering. In Spark that works in the same way as in Scala.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692661_711472831","id":"20160608-202711_739446510","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>3 Filtering Data</h1>\n<p>The next complex operation is filtering. In Spark that works in the same way as in Scala.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13103"},{"text":"val result = // YOUR CODE HERE\n\nresult.collect().foreach(println)","dateUpdated":"2018-11-14T19:14:28+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/text","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692661_711472831","id":"20160608-202711_389628381","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13104"},{"text":"%md\n# 4 Aggregations\n\nSo far we have looked at simple transformations, where each record is transformed independently. The next level of complexity is *global aggregations*. The simplest aggregation is the number of records. But Spark also supports some more common aggregations out of the box.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692662_712627078","id":"20160608-202711_806559764","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>4 Aggregations</h1>\n<p>So far we have looked at simple transformations, where each record is transformed independently. The next level of complexity is <em>global aggregations</em>. The simplest aggregation is the number of records. But Spark also supports some more common aggregations out of the box.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13105"},{"text":"println(s\"Count=${numbers.count()}\")\nprintln(s\"Sum=${numbers.sum()}\")\nprintln(s\"Mean=${numbers.mean()}\")\nprintln(s\"Min=${numbers.min()}\")\nprintln(s\"Max=${numbers.max()}\")\nprintln(s\"Variance=${numbers.variance()}\")\nprintln(s\"Stddev=${numbers.stdev()}\")\nprintln(s\"SampleVariance=${numbers.sampleVariance()}\")\nprintln(s\"SampleStddev=${numbers.sampleStdev()}\")\n","dateUpdated":"2018-11-14T19:11:32+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692662_712627078","id":"20160608-202711_933173684","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13106"},{"text":"%md\n## 4.1 Simple statistics\nFor numeric RDDs Spark also provides a method `stats()` which provides some basic statistics like minimum, maximum average etc","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692662_712627078","id":"20181110-143418_1234273588","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>4.1 Simple statistics</h2>\n<p>For numeric RDDs Spark also provides a method <code>stats()</code> which provides some basic statistics like minimum, maximum average etc</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13107"},{"text":"val result = // YOUR CODE HERE\n\nprintln(result)","dateUpdated":"2018-11-14T19:14:39+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692662_712627078","id":"20160608-202711_777032947","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13108"},{"text":"%md\n## 4.2 Aggregation via `reduce`\n\nIn many real world cases the built in aggregations are not powerful enough. But as with Scala, Spark also supports generic aggregations via a `reduce` method.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692663_712242329","id":"20181110-140615_1089818781","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>4.2 Aggregation via <code>reduce</code></h2>\n<p>In many real world cases the built in aggregations are not powerful enough. But as with Scala, Spark also supports generic aggregations via a <code>reduce</code> method.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13109"},{"text":"val result = // YOUR CODE HERE\n\nprintln(result)","dateUpdated":"2018-11-14T19:14:53+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692663_712242329","id":"20160608-202711_744682822","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13110"},{"text":"%md\n## 4.3 Aggregation via `aggregate`\n\nSince `reduce` has many limitations, Spark provides a more generic and powerful aggregation method called `aggregate`. This generic method requires three parameters:\n* starting value\n* partial aggregation function\n* final aggregation function\n\nLet us have a look at an example for calculating the average value. Conceptionally this can be achieved by counting the number of records and summing up all values. We could do that with two `reduce` invocations, but these functions are expensive, so we seek some way to perform both aggregations at the same time. This can be done with the `aggregate` method and appropriate aggregation state functions.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692663_712242329","id":"20181110-140654_191471293","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>4.3 Aggregation via <code>aggregate</code></h2>\n<p>Since <code>reduce</code> has many limitations, Spark provides a more generic and powerful aggregation method called <code>aggregate</code>. This generic method requires three parameters:<br/>* starting value<br/>* partial aggregation function<br/>* final aggregation function</p>\n<p>Let us have a look at an example for calculating the average value. Conceptionally this can be achieved by counting the number of records and summing up all values. We could do that with two <code>reduce</code> invocations, but these functions are expensive, so we seek some way to perform both aggregations at the same time. This can be done with the <code>aggregate</code> method and appropriate aggregation state functions.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13111"},{"text":"// YOUR CODE HERE","dateUpdated":"2018-11-14T19:15:06+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692664_710318585","id":"20160608-202711_349494638","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13112"},{"text":"%md\n## 4.4 Non-Trivial Aggeragtion for Counting Words\n\nAnother example uses a Scala map as aggregation state and performs a word count.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":{},"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692664_710318585","id":"20180619-075858_1165292118","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>4.4 Non-Trivial Aggeragtion for Counting Words</h2>\n<p>Another example uses a Scala map as aggregation state and performs a word count.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13113"},{"text":"val words = alice.flatMap(line => line.split(\" \"))\nwords.take(10).foreach(println)","dateUpdated":"2018-11-14T19:11:32+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692664_710318585","id":"20180619-075912_1258205514","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13114"},{"text":"val zero = Map[String,Int]()\ndef reduce(map:Map[String,Int], word:String) : Map[String,Int] = map.updated(word, map.getOrElse(word, 0) + 1)\ndef combine(left:Map[String,Int], right:Map[String,Int]) : Map[String,Int] = {\n    val words = left.keySet ++ right.keySet\n    words.map(word => (word,left.getOrElse(word, 0) + right.getOrElse(word, 0))).toMap\n}\n\nval counts = words.aggregate(zero)(reduce, combine)","dateUpdated":"2018-11-14T19:11:32+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692664_710318585","id":"20180619-075923_250735613","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13115"},{"text":"%md\n# 5 Making Data Distinct\n\nSpark provides also a very simple method for making records distinct. This can be useful after a `union` operation.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692664_710318585","id":"20160608-202711_588606321","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>5 Making Data Distinct</h1>\n<p>Spark provides also a very simple method for making records distinct. This can be useful after a <code>union</code> operation.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13116"},{"text":"val rdd = sc.parallelize(List('b','a','c','c','a'))\nval result = // YOUR CODE HERE\n\nprintln(result.collect().mkString(\",\"))","dateUpdated":"2018-11-14T19:15:21+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692665_709933836","id":"20160608-202711_1396758965","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13117"},{"text":"%md\n# 6 Intermission: Calculating Pi\n\nLet us use Spark to perform a randomized approximation of the constant pi. The idea is as follows:\n\n1. Generate `n` random points in the square `[0,1]x[0,1]`\n2. For each point, check if it is inside the circle with radius 0 around the center point `(0,0)`. This is the case for all points `(x,y)` with `x*x + y*y <= 1`.\n3. Count the number of these points inside the unit circle. We denote the number with `m`\n4. Pi can be approximated via `pi = 4*m/n`","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692665_709933836","id":"20170227-233340_1388824956","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>6 Intermission: Calculating Pi</h1>\n<p>Let us use Spark to perform a randomized approximation of the constant pi. The idea is as follows:</p>\n<ol>\n  <li>Generate <code>n</code> random points in the square <code>[0,1]x[0,1]</code></li>\n  <li>For each point, check if it is inside the circle with radius 0 around the center point <code>(0,0)</code>. This is the case for all points <code>(x,y)</code> with <code>x*x + y*y &lt;= 1</code>.</li>\n  <li>Count the number of these points inside the unit circle. We denote the number with <code>m</code></li>\n  <li>Pi can be approximated via <code>pi = 4*m/n</code></li>\n</ol>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13118"},{"text":"val numbers = ...\nval points = ... // use scla.util.Random.nextFloat()\nval insidePoints = ... // x*x + y*y <= 1.0\nval numberOfInsidePoints = ...\n\nval pi = 4 * numberOfInsidePoints / totalNumberOfPoints","dateUpdated":"2018-11-14T19:11:32+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692665_709933836","id":"20180619-080537_306482722","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13119"},{"text":"%md\n# 7 Working with Key-Value Data\n\nSo far we have been looking at either simple transformations or at global aggregations. But most more powerful algorithms need grouped aggregations and/or joins. Both topics require using *key-value* pairs instead of simple values. Spark provides lots of additional functionality for *pairs* of values (2-tuples), which are interpreted as key-values pairs.\n\nSo let us first generate some key value pairs, which are represented as Scala-2-tuples (pairs):","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692665_709933836","id":"20160608-202711_1184179398","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>7 Working with Key-Value Data</h1>\n<p>So far we have been looking at either simple transformations or at global aggregations. But most more powerful algorithms need grouped aggregations and/or joins. Both topics require using <em>key-value</em> pairs instead of simple values. Spark provides lots of additional functionality for <em>pairs</em> of values (2-tuples), which are interpreted as key-values pairs.</p>\n<p>So let us first generate some key value pairs, which are represented as Scala-2-tuples (pairs):</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13120"},{"text":"val kv = // YOUR CODE HERE\nval keys = // YOUR CODE HERE\n\nkeys.foreach(k => /* YOUR CODE HERE */)\n","dateUpdated":"2018-11-14T19:16:22+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692666_711088082","id":"20160608-202711_1772185437","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13121"},{"text":"%md\n## 7.1 Transforming values\n\nOften keys are constant and only the values need to be transformed. This kind of operations is diectly supported in Spark via a dedicated `mapValues` method. Of course you *could* use a `map` method instead, but it may well be the case that you have to pay significantly more, because Spark has no idea how keys would be transformed. And keys may play a special role when you use grouped aggregations and joins (more on these two operations later).","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692666_711088082","id":"20181110-162842_1173163535","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>7.1 Transforming values</h2>\n<p>Often keys are constant and only the values need to be transformed. This kind of operations is diectly supported in Spark via a dedicated <code>mapValues</code> method. Of course you <em>could</em> use a <code>map</code> method instead, but it may well be the case that you have to pay significantly more, because Spark has no idea how keys would be transformed. And keys may play a special role when you use grouped aggregations and joins (more on these two operations later).</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13122"},{"text":"val kv = sc.parallelize(Array((\"a\" -> 1), (\"b\" -> 3), (\"c\" -> 17), (\"b\" -> 23), (\"c\" -> 12)))\nval result = // YOUR CODE HERE\n\nprintln(result.collect().mkString(\",\"))","dateUpdated":"2018-11-14T19:16:06+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692666_711088082","id":"20160608-202711_1669939416","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13123"},{"text":"%md\n# 8 Grouping Data\nWe have just seen how to create key-value data, now we want to investigate the first operation: grouping data. The idea is like a SQL `GROUP BY` operation, but without aggregation. A simple Spark `groupBy` or `groupByKey` simply collects all records having the same key into a list of records.\n\nThe first operation we'll use is `groupByKey` which assumes key-value data.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692667_710703334","id":"20160608-202711_544797547","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>8 Grouping Data</h1>\n<p>We have just seen how to create key-value data, now we want to investigate the first operation: grouping data. The idea is like a SQL <code>GROUP BY</code> operation, but without aggregation. A simple Spark <code>groupBy</code> or <code>groupByKey</code> simply collects all records having the same key into a list of records.</p>\n<p>The first operation we&rsquo;ll use is <code>groupByKey</code> which assumes key-value data.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13124"},{"text":"val result = // YOUR CODE HERE\n\nprintln(result.collect().mkString(\",\"))","dateUpdated":"2018-11-14T19:16:22+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692667_710703334","id":"20160608-202711_1689585268","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13125"},{"text":"%md\nIn cases where you do not already have key-value data, or you need to perform the grouping on a different key, you can also specify an arbitrary operation in the `groupBy` method for extracting the key.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692667_710703334","id":"20181110-163230_109592255","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<p>In cases where you do not already have key-value data, or you need to perform the grouping on a different key, you can also specify an arbitrary operation in the <code>groupBy</code> method for extracting the key.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13126"},{"text":"val result = // YOUR CODE HERE\n\nresult.collect().foreach(x => println(x._1 + \" : \" + x._2.mkString(\",\")))","dateUpdated":"2018-11-14T19:17:05+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/text","colWidth":12,"editorHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692667_710703334","id":"20160608-202711_683334995","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13127"},{"text":"%md\n# 9 Aggregating Key-Value Data\n\nNow we have seen how groups of records sharing the same key can be created. The next commonly used operation is an aggregation. You could perform a standard Scala aggregation directly with these groups using a `mapValues` method after the `groupBy` method as follows:","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692668_708779589","id":"20160608-202711_1207982069","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>9 Aggregating Key-Value Data</h1>\n<p>Now we have seen how groups of records sharing the same key can be created. The next commonly used operation is an aggregation. You could perform a standard Scala aggregation directly with these groups using a <code>mapValues</code> method after the <code>groupBy</code> method as follows:</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13128"},{"text":"val result = // YOUR CODE HERE\n\nresult.collect().foreach(println)","dateUpdated":"2018-11-14T19:17:05+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692668_708779589","id":"20160608-202711_68716809","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13129"},{"text":"%md\n## 9.1 Grouped aggregation via `reduceByKey`\n\nActually the `groupBy` operation is really expensive and memory intensive, because in the first step Spark has to shuffle all the data, such that all records having the same key are in the same list. But if we want to perform an aggregation on the result, it is a better idea to perform the following steps:\n\n1. Perform local partial aggregations per Spark executor\n2. Shuffle partial results\n3. Perform final aggregation of partial results\n \nThis approach reduces the amount of data that need to be shuffled between the worker nodes in the cluster. In order to use this mechanics, we need to use a `reduceByKey` method instead of a `groupBy` followed by a `mapValues`","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692668_708779589","id":"20181110-163536_1670726171","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>9.1 Grouped aggregation via <code>reduceByKey</code></h2>\n<p>Actually the <code>groupBy</code> operation is really expensive and memory intensive, because in the first step Spark has to shuffle all the data, such that all records having the same key are in the same list. But if we want to perform an aggregation on the result, it is a better idea to perform the following steps:</p>\n<ol>\n  <li>Perform local partial aggregations per Spark executor</li>\n  <li>Shuffle partial results</li>\n  <li>Perform final aggregation of partial results</li>\n</ol>\n<p>This approach reduces the amount of data that need to be shuffled between the worker nodes in the cluster. In order to use this mechanics, we need to use a <code>reduceByKey</code> method instead of a <code>groupBy</code> followed by a <code>mapValues</code></p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13130"},{"text":"val result = // YOUR CODE HERE\n\nresult.collect().foreach(println)","dateUpdated":"2018-11-14T19:17:05+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692669_708394840","id":"20160608-202711_1724690424","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13131"},{"text":"%md\n## 9.2 Grouped counting\nSpark even supports a special aggregation called `countByKey`, but this does return a local Scala collection and not an RDD","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692669_708394840","id":"20181110-163721_511931057","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>9.2 Grouped counting</h2>\n<p>Spark even supports a special aggregation called <code>countByKey</code>, but this does return a local Scala collection and not an RDD</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13132"},{"text":"val result = // YOUR CODE HERE\n\nprintln(result.mkString(\",\"))","dateUpdated":"2018-11-14T19:17:05+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692669_708394840","id":"20160608-202711_244234945","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13133"},{"text":"%md\nSpark also supports a `countByValue` method, where `value` does not refer to the value of a key-value pair, but simply to the full record.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692669_708394840","id":"20181110-164151_74670773","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<p>Spark also supports a <code>countByValue</code> method, where <code>value</code> does not refer to the value of a key-value pair, but simply to the full record.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13134"},{"text":"val rdd = sc.parallelize(Array(\"a\", \"b\", \"c\", \"b\", \"c\"))\nval result =  // YOUR CODE HERE\n\nprintln(result.mkString(\",\"))","dateUpdated":"2018-11-14T19:17:05+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692670_709549087","id":"20160608-202711_1015471198","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13135"},{"text":"%md\n## 9.3 Grouped aggregation via `aggregateByKey`\n\nSince `reduceByKey` has many limitations, Spark provides a more generic and powerful aggregation method called `aggregateByKey`. This generic method requires three parameters:\n* starting value\n* partial aggregation function\n* final aggregation function\n\nLet us have a look at an example for calculating the average value per grouping key. Conceptionally this can be achieved by counting the number of records and summing up all values. We could do that with two `reduceByKey` invocations, but these functions are expensive, so we seek some way to perform both aggregations at the same time. This can be done with the `aggregateByKey` method and appropriate aggregation state functions.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692670_709549087","id":"20160608-202711_971882077","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>9.3 Grouped aggregation via <code>aggregateByKey</code></h2>\n<p>Since <code>reduceByKey</code> has many limitations, Spark provides a more generic and powerful aggregation method called <code>aggregateByKey</code>. This generic method requires three parameters:<br/>* starting value<br/>* partial aggregation function<br/>* final aggregation function</p>\n<p>Let us have a look at an example for calculating the average value per grouping key. Conceptionally this can be achieved by counting the number of records and summing up all values. We could do that with two <code>reduceByKey</code> invocations, but these functions are expensive, so we seek some way to perform both aggregations at the same time. This can be done with the <code>aggregateByKey</code> method and appropriate aggregation state functions.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13136"},{"text":"val zero = (0.0, 0)\ndef reducer(acc:(Double,Int), value:Double) = (acc._1 + value, acc._2 + 1)\ndef combiner(left:(Double,Int), right:(Double,Int)) = (left._1 + right._1, left._2 + right._2)\n\nval rdd = sc.parallelize(Array((\"a\",1.0), (\"b\",3.0), (\"c\", 17.0), (\"b\", 23.0), (\"c\",12.0)))\nval result = // YOUR CODE HERE\n\nprintln(result.collect().mkString(\",\"))","dateUpdated":"2018-11-14T19:17:57+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692670_709549087","id":"20160608-202711_661449057","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13137"},{"text":"%md\n# 10 Sorting Data\n\nNormally the records in an RDD are not ordered, but of course in many cases you want to sort the results (so the most important records are at the beginning). This is supported by a `sortBy` method, where you specify a function for extracting the key and optionally a sorting order.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692670_709549087","id":"20160608-202711_1598944127","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>10 Sorting Data</h1>\n<p>Normally the records in an RDD are not ordered, but of course in many cases you want to sort the results (so the most important records are at the beginning). This is supported by a <code>sortBy</code> method, where you specify a function for extracting the key and optionally a sorting order.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13138"},{"text":"val result = // YOUR CODE HERE\n\nprintln(result.collect().mkString(\",\"))","dateUpdated":"2018-11-14T19:17:58+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692671_709164338","id":"20160608-202711_1991067578","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13139"},{"text":"%md\nFor simpe cases Spark also supports a `sortByKey` method.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692671_709164338","id":"20181110-164448_1237092597","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<p>For simpe cases Spark also supports a <code>sortByKey</code> method.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13140"},{"text":"val result = // YOUR CODE HERE\n\nprintln(result.collect().mkString(\",\"))","dateUpdated":"2018-11-14T19:17:58+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692671_709164338","id":"20160608-202711_1782595892","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13141"},{"text":"%md\n# 11 Storing Data\n\nEventuall you also want to store results back into HDFS or S3 (or whatever filesystem you are using). Spark provides a couple of methods for different file formats:\n* `saveAsTextFile` saves this RDD as a compressed text file, using string representations of elements.\n* `saveAsObjectFile` saves this RDD as a text file, using string representations of elements.\n* `saveAsHadoopDataset`, `saveAsHadoopFile`, `saveAsNewAPIHadoopFile` saves the RDD as a Hadoop file type","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692672_694928629","id":"20160608-202711_438135470","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>11 Storing Data</h1>\n<p>Eventuall you also want to store results back into HDFS or S3 (or whatever filesystem you are using). Spark provides a couple of methods for different file formats:<br/>* <code>saveAsTextFile</code> saves this RDD as a compressed text file, using string representations of elements.<br/>* <code>saveAsObjectFile</code> saves this RDD as a text file, using string representations of elements.<br/>* <code>saveAsHadoopDataset</code>, <code>saveAsHadoopFile</code>, <code>saveAsNewAPIHadoopFile</code> saves the RDD as a Hadoop file type</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13142"},{"text":"// YOUR CODE HERE","dateUpdated":"2018-11-14T19:17:58+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692672_694928629","id":"20160608-202711_21418727","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13143"},{"text":"%sh\nhdfs dfs -getmerge /user/zeppelin/numbers /tmp/numbers.txt\ncat /tmp/numbers.txt | head -n10","dateUpdated":"2018-11-14T19:11:32+0000","config":{"editorSetting":{"language":"sh","editOnDblClick":false},"editorMode":"ace/mode/sh","colWidth":12,"editorHide":false,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692672_694928629","id":"20160608-202711_1354775640","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13144"},{"text":"%md\n# 12 Intermission: WordCount\n\nNow we have everything to implement the famous word count example with Apache Spark. The steps are as follows:\n1. Read in some text file (we use *Alice in Wonderland* at `s3://dimajix-training/data/alice`)\n2. Split each line into words\n3. Remove empty words\n4. Transform each word into a key-value pair `(word,1)`\n5. Perform a grouped aggregation for counting the occurances of each word\n6. Sort by number of occurances in descending order\n7. Save the result to HDFS (maybe to `/user/zeppelin/alice_counts`)","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692673_694543880","id":"20170227-233458_1147166395","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>12 Intermission: WordCount</h1>\n<p>Now we have everything to implement the famous word count example with Apache Spark. The steps are as follows:<br/>1. Read in some text file (we use <em>Alice in Wonderland</em> at <code>s3://dimajix-training/data/alice</code>)<br/>2. Split each line into words<br/>3. Remove empty words<br/>4. Transform each word into a key-value pair <code>(word,1)</code><br/>5. Perform a grouped aggregation for counting the occurances of each word<br/>6. Sort by number of occurances in descending order<br/>7. Save the result to HDFS (maybe to <code>/user/zeppelin/alice_counts</code>)</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13145"},{"text":"val text = sc.textFile(\"s3://dimajix-training/data/alice\")\nval words = // YOUR CODE HERE\n    ","dateUpdated":"2018-11-14T19:17:58+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692673_694543880","id":"20181110-141209_759763098","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13146"},{"text":"%md\n### Inspect Result\nLet us inspect the result using HDFS command line utilities","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692673_694543880","id":"20181110-165150_1769302106","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3>Inspect Result</h3>\n<p>Let us inspect the result using HDFS command line utilities</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13147"},{"text":"%sh\nhdfs dfs -getmerge /user/zeppelin/alice_counts /tmp/alice_counts.txt\ncat /tmp/alice_counts.txt | head -n20","dateUpdated":"2018-11-14T19:11:32+0000","config":{"colWidth":12,"editorMode":"ace/mode/sh","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692673_694543880","id":"20181110-141223_1395030879","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13148"},{"text":"%md\n# 13 Joining Data\n\nThere is one important operation still missing required for a relational algebra: joining multiple RDDs. Of course this is also well supported in Apache Spark, although things get a little bit confusing because of lots of tuples we have to work with...","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692674_695698126","id":"20160608-202711_137688962","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>13 Joining Data</h1>\n<p>There is one important operation still missing required for a relational algebra: joining multiple RDDs. Of course this is also well supported in Apache Spark, although things get a little bit confusing because of lots of tuples we have to work with&hellip;</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13149"},{"text":"val x = sc.parallelize(Array((\"a\", 1), (\"b\", 4)))\nval y = sc.parallelize(Array((\"a\", 2), (\"c\", 8)))","dateUpdated":"2018-11-14T19:11:32+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692674_695698126","id":"20160608-202711_1298496515","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13150"},{"text":"%md\n### Full outer join\n\nFirst let us perform a full outer join of both RDDs `x` and `y`. In the Spark RDD world, joins always require key-value data on both sides of the join (left and right).\n\nA full outer join will create a RDD with the following tuple\n```\n    (KEY_TYPE, (Option[LEFT_VALUE_TYPE], Option[RIGHT_VALUE_TYPE]))\n```\n\nSpark uses `Option`s to be able to model `NULL` values.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692674_695698126","id":"20181110-165402_1420913110","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3>Full outer join</h3>\n<p>First let us perform a full outer join of both RDDs <code>x</code> and <code>y</code>. In the Spark RDD world, joins always require key-value data on both sides of the join (left and right).</p>\n<p>A full outer join will create a RDD with the following tuple</p>\n<pre><code>    (KEY_TYPE, (Option[LEFT_VALUE_TYPE], Option[RIGHT_VALUE_TYPE]))\n</code></pre>\n<p>Spark uses <code>Option</code>s to be able to model <code>NULL</code> values.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13151"},{"text":"val result = // YOUR CODE HERE\n\nresult.collect().foreach(println)","dateUpdated":"2018-11-14T19:17:58+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692675_695313378","id":"20181110-141018_1108005333","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13152"},{"text":"%md\n### Inner join\n\nAn inner join works similar, but the result does not use options (since the inner join cannot produce `NULL` values for either side). So the resulting data type looks as follows:\n\n```\n    (KEY_TYPE, (LEFT_VALUE_TYPE, RIGHT_VALUE_TYPE))\n```","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692675_695313378","id":"20181110-165423_1618351793","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3>Inner join</h3>\n<p>An inner join works similar, but the result does not use options (since the inner join cannot produce <code>NULL</code> values for either side). So the resulting data type looks as follows:</p>\n<pre><code>    (KEY_TYPE, (LEFT_VALUE_TYPE, RIGHT_VALUE_TYPE))\n</code></pre>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13153"},{"text":"val result = // YOUR CODE HERE\n\nresult.collect().foreach(println)","dateUpdated":"2018-11-14T19:18:17+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692675_695313378","id":"20160608-202711_1102106791","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13154"},{"text":"%md\n### Left outer join\n\nNow you should have an idea how a left outer join works, and how the result looks like. Since the right side could be missing, an `Option` is only used for the second (right) value:\n\n```\n    (KEY_TYPE, (LEFT_VALUE_TYPE, Option[RIGHT_VALUE_TYPE]))\n```","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692675_695313378","id":"20181110-165800_1941147381","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3>Left outer join</h3>\n<p>Now you should have an idea how a left outer join works, and how the result looks like. Since the right side could be missing, an <code>Option</code> is only used for the second (right) value:</p>\n<pre><code>    (KEY_TYPE, (LEFT_VALUE_TYPE, Option[RIGHT_VALUE_TYPE]))\n</code></pre>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13155"},{"text":"val result = // YOUR CODE HERE\n\nresult.collect().foreach(println)","dateUpdated":"2018-11-14T19:18:17+0000","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"results":[{"graph":{"mode":"multiBarChart","height":294,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692676_693389633","id":"20160608-202711_1062380962","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13156"},{"text":"%md\n### Right outer join\n\nThe right outer join is no surprise any more, an `Option` is only used for the first (left) value:\n\n```\n    (KEY_TYPE, (Option[LEFT_VALUE_TYPE], RIGHT_VALUE_TYPE))\n```","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692676_693389633","id":"20181110-165950_778548671","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h3>Right outer join</h3>\n<p>The right outer join is no surprise any more, an <code>Option</code> is only used for the first (left) value:</p>\n<pre><code>    (KEY_TYPE, (Option[LEFT_VALUE_TYPE], RIGHT_VALUE_TYPE))\n</code></pre>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13157"},{"text":"val result = x.rightOuterJoin(y)\n\nresult.collect().foreach(println)","dateUpdated":"2018-11-14T19:11:32+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692676_693389633","id":"20160608-202711_1257787176","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13158"},{"text":"%md\n# 14 Sampling and Splitting\n\nSometimes you only want to work with a random sample of the data. This is also supported by Spark with the `sample` method:","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692677_693004884","id":"20160608-202711_1947529611","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>14 Sampling and Splitting</h1>\n<p>Sometimes you only want to work with a random sample of the data. This is also supported by Spark with the <code>sample</code> method:</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13159"},{"text":"val result = // YOUR CODE HERE\nprintln(result.count())","dateUpdated":"2018-11-14T19:19:23+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692677_693004884","id":"20160608-202711_184424503","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13160"},{"text":"%md\n## 14.1 Random splitting\nSpark also supports randomly splitting an RDD into multiple different RDDs. This is very important in Machine Learning, where you traditionally need to split up the data into a training, validation and testing set.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692677_693004884","id":"20181110-170153_748619240","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>14.1 Random splitting</h2>\n<p>Spark also supports randomly splitting an RDD into multiple different RDDs. This is very important in Machine Learning, where you traditionally need to split up the data into a training, validation and testing set.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13161"},{"text":"val Array(a,b) = // YOUR CODE HERE\n\nprintln(s\"#A: ${a.count()}\")\nprintln(s\"#B: ${b.count()}\")","dateUpdated":"2018-11-14T19:19:23+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692677_693004884","id":"20160608-202711_803719300","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13162"},{"text":"%md\n# 15 Caching Data\n\nIn some situations, you may want to persist intermediate results. For example iterative algorithms may benefit from *caching* intermediate results, if the same RDD is transformed again and again. Spark provides some capabilities to persist intermediate results using the methods `cache()` or `persist(storageLevel)`.\n\nNote that also caching is lazy, which means that records will not be created at the time when you call `cache()` or `persist()` but at the first time when the RDD is evaluated. This could be even a simple `count()` action.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692678_694159131","id":"20160617-161239_1195207148","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>15 Caching Data</h1>\n<p>In some situations, you may want to persist intermediate results. For example iterative algorithms may benefit from <em>caching</em> intermediate results, if the same RDD is transformed again and again. Spark provides some capabilities to persist intermediate results using the methods <code>cache()</code> or <code>persist(storageLevel)</code>.</p>\n<p>Note that also caching is lazy, which means that records will not be created at the time when you call <code>cache()</code> or <code>persist()</code> but at the first time when the RDD is evaluated. This could be even a simple <code>count()</code> action.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13163"},{"text":"val rdd = sc.parallelize(0 to 1000)\n\n// YOUR CODE HERE\n\nprintln(rdd.count())","dateUpdated":"2018-11-14T19:19:23+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692678_694159131","id":"20160617-161253_1903777045","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13164"},{"text":"%md\nIn order to free up some memory again, the DataFrame can also be uncached. This is done with the `unpersist` method.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692678_694159131","id":"20181110-170612_982341174","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<p>In order to free up some memory again, the DataFrame can also be uncached. This is done with the <code>unpersist</code> method.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13165"},{"text":"// YOUR CODE HERE","dateUpdated":"2018-11-14T19:19:23+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692678_694159131","id":"20160617-161457_1882675347","result":{"code":"SUCCESS","type":"TEXT","msg":"\nres59: rdd.type = Numbers 0 to 1000 ParallelCollectionRDD[128] at parallelize at <console>:31\n"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13166"},{"text":"%md\nIn addition to the simple `cache` method, Spark also provides a `persist` method, which lets you define precisely how the data should be cached: In memory, on disk or with a mixture of both storages.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692679_693774382","id":"20181110-170633_848505365","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<p>In addition to the simple <code>cache</code> method, Spark also provides a <code>persist</code> method, which lets you define precisely how the data should be cached: In memory, on disk or with a mixture of both storages.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13167"},{"text":"import org.apache.spark.storage.StorageLevel\n\nrdd.persist(StorageLevel.MEMORY_AND_DISK)","dateUpdated":"2018-11-14T19:11:32+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692679_693774382","id":"20181110-170639_1323923864","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13168"},{"text":"%md\n# 16 Working with Partitions\n\nInternally Spark splits up all records of an RDD into partitions. It thereby splits up both the data and also the work. The number of partitions has a direct impact on the parallelism of all operations, therefore it is often important to explicitly control the number of partitions.\n\nYou can retrieve the number of partitions of an RDD by accessing its `partitions` member","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692679_693774382","id":"20160619-093019_1230772729","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h1>16 Working with Partitions</h1>\n<p>Internally Spark splits up all records of an RDD into partitions. It thereby splits up both the data and also the work. The number of partitions has a direct impact on the parallelism of all operations, therefore it is often important to explicitly control the number of partitions.</p>\n<p>You can retrieve the number of partitions of an RDD by accessing its <code>partitions</code> member</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13169"},{"text":"// YOUR CODE HERE","dateUpdated":"2018-11-14T19:19:23+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692679_693774382","id":"20160619-093034_316796552","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13170"},{"text":"%md\n## 16.1 Repartitioning\n\nYou can also explicitly repartition the data, either by only specifying the number of partitions or by also specifying an explicit partitioning algorithm.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692680_691850637","id":"20181110-170918_1436647055","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>16.1 Repartitioning</h2>\n<p>You can also explicitly repartition the data, either by only specifying the number of partitions or by also specifying an explicit partitioning algorithm.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13171"},{"text":"// YOUR CODE HERE","dateUpdated":"2018-11-14T19:19:23+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692680_691850637","id":"20160619-093126_1951060033","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13172"},{"text":"%md\n## 16.2 Coalescing partitions\n\nA special form of chaning the number of partitions is to logically *coalesce* them together without performing an actual shuffle operation. This is quite useful before writing results to disk in order to keep the number of files low.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692680_691850637","id":"20181110-141126_857137719","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>16.2 Coalescing partitions</h2>\n<p>A special form of chaning the number of partitions is to logically <em>coalesce</em> them together without performing an actual shuffle operation. This is quite useful before writing results to disk in order to keep the number of files low.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13173"},{"text":"// YOUR CODE HERE","dateUpdated":"2018-11-14T19:19:23+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692681_691465889","id":"20181110-171103_576299949","result":{"code":"SUCCESS","type":"TEXT","msg":""},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13174"},{"text":"%sh\nhdfs dfs -ls /user/zeppelin/rdd_32p","dateUpdated":"2018-11-14T19:11:32+0000","config":{"colWidth":12,"editorMode":"ace/mode/sh","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692681_691465889","id":"20181110-171133_2040306891","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13175"},{"text":"val rdd_4p = // YOUR CODE HERE\nrdd_4p.saveAsTextFile(\"/user/zeppelin/rdd_4p\")","dateUpdated":"2018-11-14T19:19:43+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692681_691465889","id":"20160619-093158_1646297391","result":{"code":"SUCCESS","type":"TEXT","msg":"\nrdd_4p: org.apache.spark.rdd.RDD[Int] = CoalescedRDD[134] at coalesce at <console>:36\n"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13176"},{"text":"%sh\nhdfs dfs -ls /user/zeppelin/rdd_4p","dateUpdated":"2018-11-14T19:11:32+0000","config":{"colWidth":12,"editorMode":"ace/mode/sh","graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692681_691465889","id":"20181110-171204_1390871642","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13177"},{"text":"%md\n## 16.2 Special Use Case: mapPartitions\n\nSometimes you do not want to work with individual elements, but with all elements of a whole partition. Typical use case is when you need to acquire an expensive additional resouce (database connection, ....), which you do not want to acquire for every element but cannot be acquired in the driver program.","dateUpdated":"2018-11-14T19:11:32+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692682_692620135","id":"20160619-093235_405645521","result":{"code":"SUCCESS","type":"HTML","msg":"<div class=\"markdown-body\">\n<h2>16.2 Special Use Case: mapPartitions</h2>\n<p>Sometimes you do not want to work with individual elements, but with all elements of a whole partition. Typical use case is when you need to acquire an expensive additional resouce (database connection, &hellip;.), which you do not want to acquire for every element but cannot be acquired in the driver program.</p>\n</div>"},"dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13178"},{"text":"val psums = // YOUR CODE HERE\nval total_sum = // YOUR CODE HERE","dateUpdated":"2018-11-14T19:11:32+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692682_692620135","id":"20160619-093306_865510153","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13179"},{"text":"","dateUpdated":"2018-11-14T19:11:32+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"results":{},"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542222692682_692620135","id":"20160619-073230_1669821313","dateCreated":"2018-11-14T19:11:32+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:13180"}],"name":"Spark RDD - Skeleton","id":"2DWUB9QTJ","angularObjects":{"2DXCSQHDQ:shared_process":[],"2DXX8TZBW:shared_process":[],"2DVWRGCNK:shared_process":[],"2DY6KEB79:shared_process":[],"2DV9MSNQX:shared_process":[],"2DV8FQ6HR:shared_process":[],"2DVZNZJ1J:shared_process":[],"2DUF3PAJB:shared_process":[],"2DX5UEWSB:shared_process":[]},"config":{"looknfeel":"default"},"info":{}}