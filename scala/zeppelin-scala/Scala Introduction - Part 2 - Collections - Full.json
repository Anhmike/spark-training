{"paragraphs":[{"text":"%md\n# 1 Immutable Collections\n\nImmutable collections are lists, maps etc that cannot be modified once they are created. All operations which would add or remove elements return a new collection instead. Scala implements all operations very efficiently, so there is no reason to avoid immutable collections. Programmers might require a new way of thinking, but once they internalized the concept, many things get much easier.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>1 Immutable Collections</h1>\n<p>Immutable collections are lists, maps etc that cannot be modified once they are created. All operations which would add or remove elements return a new collection instead. Scala implements all operations very efficiently, so there is no reason to avoid immutable collections. Programmers might require a new way of thinking, but once they internalized the concept, many things get much easier.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142503_1830979460","id":"20160618-172534_35131859","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:1142"},{"text":"%md\n## 1.1 Ranges\n\nPossibly the simplest collection is  a range which contains some numbers.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>1.1 Ranges</h2>\n<p>Possibly the simplest collection is a range which contains some numbers.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142509_1827131971","id":"20160619-064134_2071814267","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1143"},{"text":"1 to 10","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres110: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"}]},"apps":[],"jobName":"paragraph_1542613142512_1838289689","id":"20160619-064144_1839541272","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1144"},{"text":"1 to 100000000","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"res111: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 1..."}]},"apps":[],"jobName":"paragraph_1542613142516_1836750694","id":"20160619-064153_1827461776","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1145"},{"text":"%md\nA `Range` object can also be created by using the static `apply` method:","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>A <code>Range</code> object can also be created by using the static <code>apply</code> method:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142518_1837520191","id":"20181112-165940_310175072","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1146"},{"text":"Range(1,20)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres112: scala.collection.immutable.Range = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)\n"}]},"apps":[],"jobName":"paragraph_1542613142520_1835211698","id":"20160619-064212_998052812","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1147"},{"text":"%md\nScala also allows to specify the stepsize between the elements in a range","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Scala also allows to specify the stepsize between the elements in a range</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142521_1834826949","id":"20181112-170025_1370381650","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1148"},{"text":"1 to 40 by 3","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres113: scala.collection.immutable.Range = Range(1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40)\n"}]},"apps":[],"jobName":"paragraph_1542613142522_1835981196","id":"20160619-064223_1003113605","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1149"},{"text":"%md\n## 1.2 Lists\n\nSince numbers are not sufficient for anything except simple counting, Lists offer the ability to store objects.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>1.2 Lists</h2>\n<p>Since numbers are not sufficient for anything except simple counting, Lists offer the ability to store objects.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142527_1834057451","id":"20160619-060448_1739451758","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1150"},{"text":"val l = List(1,2,3)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nl: List[Int] = List(1, 2, 3)\n"}]},"apps":[],"jobName":"paragraph_1542613142531_1524719336","id":"20160619-062500_1197938739","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1151"},{"text":"%md\nScala also supports another way of specifying a list using double colons (`::`)) together with a not-in-list element (`Nil`) as end marker.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Scala also supports another way of specifying a list using double colons (<code>::</code>)) together with a not-in-list element (<code>Nil</code>) as end marker.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142534_1523565089","id":"20181112-170212_1814567191","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1152"},{"text":"val l123 = 1 :: 2 :: 3 ::Nil","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nl123: List[Int] = List(1, 2, 3)\n"}]},"apps":[],"jobName":"paragraph_1542613142537_1520871847","id":"20160619-062524_1526632533","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1153"},{"text":"%md\nA new element can be added to then end of a list by using the `:+` operator. This will actually not modify the list itself, but return a new list containing the original elements with the specified element appended.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>A new element can be added to then end of a list by using the <code>:+</code> operator. This will actually not modify the list itself, but return a new list containing the original elements with the specified element appended.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142540_1519717600","id":"20181112-170100_1162738461","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1154"},{"text":"val l1234 = l :+ 4","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nl1234: List[Int] = List(1, 2, 3, 4)\n"}]},"apps":[],"jobName":"paragraph_1542613142543_1520102349","id":"20160619-062513_1813256359","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1155"},{"text":"%md\nScala also supports adding a new element at the beginning of a list using a similar operator.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Scala also supports adding a new element at the beginning of a list using a similar operator.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142546_1531260067","id":"20181112-170340_662065578","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1156"},{"text":"val l4123 = 4 +: l","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nl4123: List[Int] = List(4, 1, 2, 3)\n"}]},"apps":[],"jobName":"paragraph_1542613142549_1528566825","id":"20181112-170315_1359699972","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1157"},{"text":"%md\n### Accessing Elements\n\nIndividual elements can be accessed via their index (starting at 0). Using the function `ìsDefinedAt` you can also inquire if a value is available for a specific index (or key).","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Accessing Elements</h3>\n<p>Individual elements can be accessed via their index (starting at 0). Using the function <code>ìsDefinedAt</code> you can also inquire if a value is available for a specific index (or key).</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142551_1529336322","id":"20160619-074106_1687305452","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1158"},{"text":"l123(1)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres114: Int = 2\n"}]},"apps":[],"jobName":"paragraph_1542613142553_1527027829","id":"20160619-074034_1204169255","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1159"},{"text":"l123 isDefinedAt(1)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres115: Boolean = true\n"}]},"apps":[],"jobName":"paragraph_1542613142554_1528182076","id":"20160619-074052_1834462124","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1160"},{"text":"%md\n## 1.3 Common Sequence Operations\n\nLists and Ranges both are special types of Sequences (`Seq`), which is the abstract concept of an ordered list of items. All types of Scala Sequences have the same methods, although their implementation might differ.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>1.3 Common Sequence Operations</h2>\n<p>Lists and Ranges both are special types of Sequences (<code>Seq</code>), which is the abstract concept of an ordered list of items. All types of Scala Sequences have the same methods, although their implementation might differ.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142555_1527797327","id":"20160619-063841_724578806","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1161"},{"text":"l123.length","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres116: Int = 3\n"}]},"apps":[],"jobName":"paragraph_1542613142557_1525488833","id":"20160619-062607_1082907838","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1162"},{"text":"l.indexOf(2)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres117: Int = 1\n"}]},"apps":[],"jobName":"paragraph_1542613142559_1526258331","id":"20160619-062642_2030433315","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1163"},{"text":"l.reverse","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres118: List[Int] = List(3, 2, 1)\n"}]},"apps":[],"jobName":"paragraph_1542613142562_1512792120","id":"20160619-062647_2144966404","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1164"},{"text":"%md\n### Creating strings\n\nAgain and again you might want to format a sequence of objects into a nice string representation. Where other languages require to write ugly for loops for inserting commas between elements, Scala provides a simple method `mkString` which automatically concetanates all elements with a user supplied separator and optionally with an opening and closing tag.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Creating strings</h3>\n<p>Again and again you might want to format a sequence of objects into a nice string representation. Where other languages require to write ugly for loops for inserting commas between elements, Scala provides a simple method <code>mkString</code> which automatically concetanates all elements with a user supplied separator and optionally with an opening and closing tag.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142566_1511253124","id":"20180320-065653_1800322397","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1165"},{"text":"l.mkString(\",\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres119: String = 1,2,3\n"}]},"apps":[],"jobName":"paragraph_1542613142570_1509714129","id":"20160619-062654_2133428485","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1166"},{"text":"l.mkString(\"[\",\",\",\"]\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres120: String = [1,2,3]\n"}]},"apps":[],"jobName":"paragraph_1542613142573_1507020886","id":"20160619-062819_1631783561","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1167"},{"text":"%md\n### Retrieving Elements\n\nIn addition to element access via the index operator, there are more methods for retrieving the first or last element, for creating sub-sequences and so on. The most famous operation (which can be used in recursive algorithms) is a decomposition of a list into a *head* element and the *tail* containing all other elements. Note that both operations do not work with an empty list.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Retrieving Elements</h3>\n<p>In addition to element access via the index operator, there are more methods for retrieving the first or last element, for creating sub-sequences and so on. The most famous operation (which can be used in recursive algorithms) is a decomposition of a list into a <em>head</em> element and the <em>tail</em> containing all other elements. Note that both operations do not work with an empty list.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142577_1517793855","id":"20160619-065047_1842887545","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1168"},{"text":"val l = (0 to 10)\nl.head","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nl: scala.collection.immutable.Range.Inclusive = Range(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n\nres121: Int = 0\n"}]},"apps":[],"jobName":"paragraph_1542613142580_1516639609","id":"20160619-065047_1189114673","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1169"},{"text":"l.tail","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres122: scala.collection.immutable.Range = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"}]},"apps":[],"jobName":"paragraph_1542613142583_1517024358","id":"20160619-071344_1985052292","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1170"},{"text":"%md\nScala also supports various variations of `take`, which returns a subsequence of at most `n` elements.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Scala also supports various variations of <code>take</code>, which returns a subsequence of at most <code>n</code> elements.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142586_1515870111","id":"20181112-170517_1217970940","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1171"},{"text":"l.take(2)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres123: scala.collection.immutable.Range = Range(0, 1)\n"}]},"apps":[],"jobName":"paragraph_1542613142587_1515485362","id":"20160619-065047_130803399","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1172"},{"text":"l.takeRight(2)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres124: scala.collection.immutable.Range = Range(9, 10)\n"}]},"apps":[],"jobName":"paragraph_1542613142589_1513176869","id":"20160619-071326_724457429","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1173"},{"text":"l.drop(3)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres125: scala.collection.immutable.Range = Range(3, 4, 5, 6, 7, 8, 9, 10)\n"}]},"apps":[],"jobName":"paragraph_1542613142591_1513946366","id":"20160619-071414_1780365131","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1174"},{"text":"l.dropRight(3)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres126: scala.collection.immutable.Range = Range(0, 1, 2, 3, 4, 5, 6, 7)\n"}]},"apps":[],"jobName":"paragraph_1542613142592_1499710657","id":"20160619-071436_1385030795","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1175"},{"text":"%md\n### Example for `head` and `tail`\n\nThe two methods `head` and `tail` often are used in recursive algorithms. Here we present a simple implementation of `foreach` without actually using `foreach`.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Example for <code>head</code> and <code>tail</code></h3>\n<p>The two methods <code>head</code> and <code>tail</code> often are used in recursive algorithms. Here we present a simple implementation of <code>foreach</code> without actually using <code>foreach</code>.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142593_1499325908","id":"20170129-114347_721814507","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1176"},{"text":"def foreach(list: List[Int], fn:(Int)=>Unit) : Unit = {\n    if (!list.isEmpty) {\n        val head = list.head\n        val tail = list.tail\n\n        fn(head)\n        foreach(tail, fn)\n    }\n}","user":"anonymous","dateUpdated":"2018-11-19T12:36:50+0000","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542630995327_901223238","id":"20181119-123635_1003749196","dateCreated":"2018-11-19T12:36:35+0000","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:1177"},{"text":"def foreach(xs: List[Int], fn:(Int)=>Unit) : Unit = {\n  xs match {\n      case head :: tail =>\n          fn(head)\n          foreach(tail, fn)\n      case List() => Unit\n  }    \n}\n  \nforeach(List(1, 9, 2, 8, 3, 7, 4), println)","dateUpdated":"2019-04-02T11:53:18+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"foreach: (xs: List[Int], fn: Int => Unit)Unit\n1\n9\n2\n8\n3\n7\n4\n()\n"}]},"apps":[],"jobName":"paragraph_1542613142595_1500095406","id":"20170129-114406_617805113","dateCreated":"2018-11-19T07:39:02+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:1178","user":"anonymous","dateFinished":"2019-04-02T11:50:10+0000","dateStarted":"2019-04-02T11:49:51+0000"},{"text":"%md\n# 2 Operations on Collections\n\nScala (as most other functional programming languages) offers many powerful operations in conjunction with collections. These operations are available not only for ranges, but for almost all collections like `Seq`, `List`, `Array`, `Map`, `Set` and some more. Using these methods oftern replace classic `for` loops and is the preferred way of iterating over all elements. Depending on your needs different types of methods provide different operations. We'll discuss the most common and important ones in the following paragraphs.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>2 Operations on Collections</h1>\n<p>Scala (as most other functional programming languages) offers many powerful operations in conjunction with collections. These operations are available not only for ranges, but for almost all collections like <code>Seq</code>, <code>List</code>, <code>Array</code>, <code>Map</code>, <code>Set</code> and some more. Using these methods oftern replace classic <code>for</code> loops and is the preferred way of iterating over all elements. Depending on your needs different types of methods provide different operations. We&rsquo;ll discuss the most common and important ones in the following paragraphs.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142596_1498171662","id":"20180321-061435_2096659814","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1179"},{"text":"%md\n## 2.1 Executing a Function on all Elements\n\nUsing the `foreach` method of a collection allows the execution of a Scala function on every item in the collection. The result of the function is ignored and `foreach` does also return nothing. This way it is well suited for simple tasks like printing all elements onto the console or mybe for writing elements to a file on disk.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>2.1 Executing a Function on all Elements</h2>\n<p>Using the <code>foreach</code> method of a collection allows the execution of a Scala function on every item in the collection. The result of the function is ignored and <code>foreach</code> does also return nothing. This way it is well suited for simple tasks like printing all elements onto the console or mybe for writing elements to a file on disk.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142598_1498941159","id":"20160619-084112_2079044468","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1180"},{"text":"(1 to 10).foreach(x => println(x))","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"}]},"apps":[],"jobName":"paragraph_1542613142601_1496247917","id":"20160619-084158_1539762657","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1181"},{"text":"1 to 10 foreach println","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n"}]},"apps":[],"jobName":"paragraph_1542613142603_1497017415","id":"20160619-084140_332095707","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1182"},{"text":"%md\n## 2.2 List Transformations\n\nScala (like other functional programming langues) provides very simple means for performing an element-wise transformation of a sequence. Where other non-functional languages require for-loops, Scala uses an approach via the `map` method which is more concise than manually iterating over all elements.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>2.2 List Transformations</h2>\n<p>Scala (like other functional programming langues) provides very simple means for performing an element-wise transformation of a sequence. Where other non-functional languages require for-loops, Scala uses an approach via the <code>map</code> method which is more concise than manually iterating over all elements.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142606_1495863168","id":"20160619-062831_1040105825","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1183"},{"text":"(1 to 1000) map (x => (x,2*x))","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"res130: scala.collection.immutable.IndexedSeq[(Int, Int)] = Vector((1,2), (2,4), (3,6), (4,8), (5,10), (6,12), (7,14), (8,16), (9,18), (10,20), (11,22), (12,24), (13,26), (14,28), (15,30), (16,32), (17,34), (18,36), (19,38), (20,40), (21,42), (22,44), (23,46), (24,48), (25,50), (26,52), (27,54), (28,56), (29,58), (30,60), (31,62), (32,64), (33,66), (34,68), (35,70), (36,72), (37,74), (38,76), (39,78), (40,80), (41,82), (42,84), (43,86), (44,88), (45,90), (46,92), (47,94), (48,96), (49,98), (50,100), (51,102), (52,104), (53,106), (54,108), (55,110), (56,112), (57,114), (58,116), (59,118), (60,120), (61,122), (62,124), (63,126), (64,128), (65,130), (66,132), (67,134), (68,136), (69,138), (70,140), (71,142), (72,144), (73,146), (74,148), (75,150), (76,152), (77,154), (78,156), (79,158), (8..."}]},"apps":[],"jobName":"paragraph_1542613142609_1505481891","id":"20160619-063917_580038831","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1184"},{"text":"%md\n### Flattening\n\nSometimes a transformation in a `map` operation does not return a single element, but instead a list of elements. Still in many cases the complete end-result should be a simple non-nested list of items. This is where `flatMap` comes into play.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Flattening</h3>\n<p>Sometimes a transformation in a <code>map</code> operation does not return a single element, but instead a list of elements. Still in many cases the complete end-result should be a simple non-nested list of items. This is where <code>flatMap</code> comes into play.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142611_1506251388","id":"20180318-175213_695275500","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1185"},{"text":"val text = Seq(\n        \"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam \",\n        \"nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam\",\n        \"erat, sed diam voluptua. At vero eos et accusam et justo duo dolores\"\n    )","user":"anonymous","dateUpdated":"2018-11-19T12:56:58+0000","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1542632205119_-101000922","id":"20181119-125645_524539881","dateCreated":"2018-11-19T12:56:45+0000","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:1186"},{"text":"(1 to 10) map(1 to _)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres131: scala.collection.immutable.IndexedSeq[scala.collection.immutable.Range.Inclusive] = Vector(Range(1), Range(1, 2), Range(1, 2, 3), Range(1, 2, 3, 4), Range(1, 2, 3, 4, 5), Range(1, 2, 3, 4, 5, 6), Range(1, 2, 3, 4, 5, 6, 7), Range(1, 2, 3, 4, 5, 6, 7, 8), Range(1, 2, 3, 4, 5, 6, 7, 8, 9), Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\n"}]},"apps":[],"jobName":"paragraph_1542613142614_1505097142","id":"20160619-064110_297712757","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1187"},{"text":"(1 to 10) flatMap ( 1 to _ )","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres132: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"}]},"apps":[],"jobName":"paragraph_1542613142616_1502788648","id":"20160619-064428_235570651","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1188"},{"text":"%md\n## 2.3 List Comprehensions using for loops\n\nActually Scala also supports something like Python list comprehension, i.e. iterating over all elements with a `for` statement, and returning a new collection. In order to transform a collection elementwise into a new collection with a `for` loop instead of the `map` method you only have to use the keyword `yield` for specifying the new element. Internally scala will translate such a `for` loop again into a `map` invocation, so it is only syntactic sugar. In most cases using `map` would be the preferred way, since using `for` loops is not with the original spirit of Scala.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>2.3 List Comprehensions using for loops</h2>\n<p>Actually Scala also supports something like Python list comprehension, i.e. iterating over all elements with a <code>for</code> statement, and returning a new collection. In order to transform a collection elementwise into a new collection with a <code>for</code> loop instead of the <code>map</code> method you only have to use the keyword <code>yield</code> for specifying the new element. Internally scala will translate such a <code>for</code> loop again into a <code>map</code> invocation, so it is only syntactic sugar. In most cases using <code>map</code> would be the preferred way, since using <code>for</code> loops is not with the original spirit of Scala.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142618_1503558146","id":"20170218-131134_232997169","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1189"},{"text":"val result = for (i <- 1 to 10) yield 2*i","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nresult: scala.collection.immutable.IndexedSeq[Int] = Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)\n"}]},"apps":[],"jobName":"paragraph_1542613142620_1501249653","id":"20170218-131115_2047885850","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1190"},{"text":"val result = for (i <- 0 to 10 if i % 2 == 0) yield 2*i","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nresult: scala.collection.immutable.IndexedSeq[Int] = Vector(0, 4, 8, 12, 16, 20)\n"}]},"apps":[],"jobName":"paragraph_1542613142622_1502019151","id":"20170218-131110_1306144078","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1191"},{"text":"%md\n## 2.4 Filtering\n\nAnother simple but important function is filtering, which allows to throw away elements of a collection. The `filter` method takes a single function as its argument, which is used as a predicate. The predicate maps every element to `true` or `false` and `filter` will keep only these elements with the predicate being true. Again, since the collection itself is immtable, `filter` actually returns a new collection and the original one stays untouched.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>2.4 Filtering</h2>\n<p>Another simple but important function is filtering, which allows to throw away elements of a collection. The <code>filter</code> method takes a single function as its argument, which is used as a predicate. The predicate maps every element to <code>true</code> or <code>false</code> and <code>filter</code> will keep only these elements with the predicate being true. Again, since the collection itself is immtable, <code>filter</code> actually returns a new collection and the original one stays untouched.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142625_1487013943","id":"20160619-075410_1828989098","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1192"},{"text":"val evens = (1 to 10000) filter (_ % 2 == 0)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"evens: scala.collection.immutable.IndexedSeq[Int] = Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 3..."}]},"apps":[],"jobName":"paragraph_1542613142627_1487783441","id":"20160619-075436_1273909358","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1193"},{"text":"val numEvens = (1 to 10000).count(_ % 2 == 0)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nnumEvens: Int = 5000\n"}]},"apps":[],"jobName":"paragraph_1542613142629_1485474948","id":"20170218-130630_81275972","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1194"},{"text":"%md\n### Check Condition\n\nThe methods `forall` and `exists` can be used to inspect all elements and test if all/one element fullfills a specific condition.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Check Condition</h3>\n<p>The methods <code>forall</code> and <code>exists</code> can be used to inspect all elements and test if all/one element fullfills a specific condition.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142631_1486244446","id":"20180318-172438_301329958","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1195"},{"text":"evens.forall(_ % 2 == 0)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres133: Boolean = true\n"}]},"apps":[],"jobName":"paragraph_1542613142632_1484320701","id":"20180318-172510_1756317861","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1196"},{"text":"evens.exists(_ % 2 == 0)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres134: Boolean = true\n"}]},"apps":[],"jobName":"paragraph_1542613142634_1485090199","id":"20180321-062026_1122790074","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1197"},{"text":"%md\n## 2.5 Collect & Partial Functions\n\nIn some cases you might want to filter and transform elements in a single step, most commonly in conjunction with matching. A `match` expression does not need to include a `case` for every possible logical case. But what will Scala do with values that cannot be matched? Actually Scala will thow a `MatchError` for any value in a `match` operation with no suitable `case`. But at the same time, Scala also offers the concept of so called *partial functions*, which are Scala functions which are not defined for every possible value for their parameters. From this point of view, an incomplete `match` is just such a partial function.\n\nCollections provide a method `collect` in addition to `map`, which works seamlessly with partial functions. `collect` will transform all values where the partial function is defined at and it will filter out all other values. This is very handy for complex `match` operations where a preceding `filter` opreation would duplicate logic and therefore violate the DRY approach (Don't Repeat Yourself).","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>2.5 Collect &amp; Partial Functions</h2>\n<p>In some cases you might want to filter and transform elements in a single step, most commonly in conjunction with matching. A <code>match</code> expression does not need to include a <code>case</code> for every possible logical case. But what will Scala do with values that cannot be matched? Actually Scala will thow a <code>MatchError</code> for any value in a <code>match</code> operation with no suitable <code>case</code>. But at the same time, Scala also offers the concept of so called <em>partial functions</em>, which are Scala functions which are not defined for every possible value for their parameters. From this point of view, an incomplete <code>match</code> is just such a partial function.</p>\n<p>Collections provide a method <code>collect</code> in addition to <code>map</code>, which works seamlessly with partial functions. <code>collect</code> will transform all values where the partial function is defined at and it will filter out all other values. This is very handy for complex <code>match</code> operations where a preceding <code>filter</code> opreation would duplicate logic and therefore violate the DRY approach (Don&rsquo;t Repeat Yourself).</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142636_1482781706","id":"20160619-075155_1355762506","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1198"},{"text":"(1 to 10) map { case i:Int if i%2==0 => i/2 }","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"ERROR","msg":[{"type":"TEXT","data":"\n\n\n\n\n\n\n\n\n\nscala.MatchError: 1 (of class java.lang.Integer)\n  at $anonfun$1.apply$mcII$sp(<console>:34)\n  at $anonfun$1.apply(<console>:34)\n  at $anonfun$1.apply(<console>:34)\n  at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234)\n  at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234)\n  at scala.collection.immutable.Range.foreach(Range.scala:160)\n  at scala.collection.TraversableLike$class.map(TraversableLike.scala:234)\n  at scala.collection.AbstractTraversable.map(Traversable.scala:104)\n  ... 48 elided\n"}]},"apps":[],"jobName":"paragraph_1542613142638_1483551203","id":"20160619-075222_1256662395","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1199"},{"text":"(1 to 10) collect { case i:Int if i%2==0 => i/2 }","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres136: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5)\n"}]},"apps":[],"jobName":"paragraph_1542613142640_1493554675","id":"20160619-074637_1204436823","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1200"},{"text":"%md\nExplicitly defining a partial function cannot be done via the `def` keyword - this will always create a normal function. Instead you have to create a value which holds an anonymous partial function.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Explicitly defining a partial function cannot be done via the <code>def</code> keyword - this will always create a normal function. Instead you have to create a value which holds an anonymous partial function.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142641_1493169926","id":"20180321-063335_1059111004","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1201"},{"text":"val pfn:PartialFunction[Int,Int]  = { case i:Int if i%2==0 => i/2 }","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\npfn: PartialFunction[Int,Int] = <function1>\n"}]},"apps":[],"jobName":"paragraph_1542613142643_1493939424","id":"20160619-074809_1703548144","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1202"},{"text":"pfn isDefinedAt 2","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres137: Boolean = true\n"}]},"apps":[],"jobName":"paragraph_1542613142644_1492015679","id":"20160619-075327_1830105658","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1203"},{"text":"%md\n## 2.6 Zipping\n\nAnother operation which can be usefuly from time to time is `zip`. This will interleave two collections by creating tuples, each with one element from each collection. Collections need to have the same size in order for `zip` to work.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>2.6 Zipping</h2>\n<p>Another operation which can be usefuly from time to time is <code>zip</code>. This will interleave two collections by creating tuples, each with one element from each collection. Collections need to have the same size in order for <code>zip</code> to work.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142646_1492785177","id":"20160619-073632_1943757960","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1204"},{"text":"val names = Seq(\"Alice\", \"Bob\", \"Eve\")\nval cities = Seq(\"Frankfurt\", \"Berlin\", \"Hamburg\")\nnames zip cities","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nnames: Seq[String] = List(Alice, Bob, Eve)\n\ncities: Seq[String] = List(Frankfurt, Berlin, Hamburg)\n\nres138: Seq[(String, String)] = List((Alice,Frankfurt), (Bob,Berlin), (Eve,Hamburg))\n"}]},"apps":[],"jobName":"paragraph_1542613142647_1492400428","id":"20160619-073647_966259938","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1205"},{"text":"%md\nA special variant of `zip` is `zipWithIndex` which creates tuples from a single collections, where each tuple has the elements index as its second element. This is very useful in cases where you need the index of every element.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>A special variant of <code>zip</code> is <code>zipWithIndex</code> which creates tuples from a single collections, where each tuple has the elements index as its second element. This is very useful in cases where you need the index of every element.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142648_1490476684","id":"20180321-063714_1961155789","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1206"},{"text":"names.zipWithIndex","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres139: Seq[(String, Int)] = List((Alice,0), (Bob,1), (Eve,2))\n"}]},"apps":[],"jobName":"paragraph_1542613142648_1490476684","id":"20160619-073801_1100798904","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1207"},{"text":"%md\nAs an example for `zipWithIndex`, we'll create a function which converts every letter of a string to lower case or upper case depending on its index position in the string.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>As an example for <code>zipWithIndex</code>, we&rsquo;ll create a function which converts every letter of a string to lower case or upper case depending on its index position in the string.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142649_1490091935","id":"20180321-063811_2065437366","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1208"},{"text":"val str = \"Hello World\"\nval indexedString = str.zipWithIndex\nval mixedCaseChars = indexedString.map(charPos => if (charPos._2 % 2 == 1) charPos._1.toUpper else charPos._1.toLower)\nmixedCaseChars.mkString","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres140: String = hElLo wOrLd!\n"}]},"apps":[],"jobName":"paragraph_1542613142650_1491246181","id":"20160619-073817_1526363907","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1209"},{"text":"%md\n# 3 Aggregations\n\nSo far we have used transformations, which work independently on every element. For example `map` is a 1:1 transformation, `flatMap` is a 1:n transformation, `filter` and `collect` are also 1:n transformations (with n being 0 or 1). Scala also offers aggregations, which coalesce all elements of a collection into a single result value. This can be quite useful not only for arithmetic use cases, but also for more complex examples.\n\nFirst let us have a look at simple standard aggregations like `min`, `max` and `sum`. These are available for all collections with appropriate data types (i.e. comparable types will provide `min` and `max` and arithemtic data types will provide `sum`).","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>3 Aggregations</h1>\n<p>So far we have used transformations, which work independently on every element. For example <code>map</code> is a 1:1 transformation, <code>flatMap</code> is a 1:n transformation, <code>filter</code> and <code>collect</code> are also 1:n transformations (with n being 0 or 1). Scala also offers aggregations, which coalesce all elements of a collection into a single result value. This can be quite useful not only for arithmetic use cases, but also for more complex examples.</p>\n<p>First let us have a look at simple standard aggregations like <code>min</code>, <code>max</code> and <code>sum</code>. These are available for all collections with appropriate data types (i.e. comparable types will provide <code>min</code> and <code>max</code> and arithemtic data types will provide <code>sum</code>).</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142651_1490861432","id":"20160619-081814_1050781522","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1210"},{"text":"val range = 1 to 1000\n\nprintln\nprintln (\"min = \" + range.min)\nprintln (\"max = \" + range.max)\nprintln (\"sum = \" + range.sum)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"range: scala.collection.immutable.Range.Inclusive = Range(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 17...\nmin = 1\nmax = 1000\nsum = 500500\n"}]},"apps":[],"jobName":"paragraph_1542613142652_1488937688","id":"20160619-081841_789914875","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1211"},{"text":"%md\n## 3.1 Reduce and Fold\n\nIn addition to the built in aggregations, Scala also provides methods for ceating custom aggregations. The simplest one is the `reduce` method, which starts with the first element in a collection and incrementally *adds* all elements to the first one.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>3.1 Reduce and Fold</h2>\n<p>In addition to the built in aggregations, Scala also provides methods for ceating custom aggregations. The simplest one is the <code>reduce</code> method, which starts with the first element in a collection and incrementally <em>adds</em> all elements to the first one.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142652_1488937688","id":"20180321-064307_10162934","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1212"},{"text":"range.reduce((x,y) => x + y)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres145: Int = 500500\n"}]},"apps":[],"jobName":"paragraph_1542613142653_1488552939","id":"20160619-082845_1009631076","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1213"},{"text":"%md\n`fold` is a slight variation of `reduce` which allows to specify a different start value.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p><code>fold</code> is a slight variation of <code>reduce</code> which allows to specify a different start value.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142654_1489707186","id":"20180321-064416_1113957689","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1214"},{"text":"range.fold(100)(_ + _)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres146: Int = 500600\n"}]},"apps":[],"jobName":"paragraph_1542613142655_1489322437","id":"20160619-083929_1234061332","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1215"},{"text":"%md\nOne notable difference between `reduce` and `fold` is that `reduce` does not work on an empty collection (since it requires at least one element as the return value), while `fold` will work nicely on empty collections.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>One notable difference between <code>reduce</code> and <code>fold</code> is that <code>reduce</code> does not work on an empty collection (since it requires at least one element as the return value), while <code>fold</code> will work nicely on empty collections.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142655_1489322437","id":"20180321-064745_787401944","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1216"},{"text":"Seq[Int]().fold(10)(_ + _)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres147: Int = 10\n"}]},"apps":[],"jobName":"paragraph_1542613142656_1573582446","id":"20180321-064719_984584047","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1217"},{"text":"Seq[Int]().reduce(_ + _)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"ERROR","msg":[{"type":"TEXT","data":"\n\n\n\n\n\njava.lang.UnsupportedOperationException: empty.reduceLeft\n  at scala.collection.LinearSeqOptimized$class.reduceLeft(LinearSeqOptimized.scala:137)\n  at scala.collection.immutable.List.reduceLeft(List.scala:84)\n  at scala.collection.TraversableOnce$class.reduce(TraversableOnce.scala:208)\n  at scala.collection.AbstractTraversable.reduce(Traversable.scala:104)\n  ... 48 elided\n"}]},"apps":[],"jobName":"paragraph_1542613142658_1574351944","id":"20180321-064734_1676015405","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1218"},{"text":"%md\n`reduce` can be seen as a special case of `fold` with the start value of `head` folded over `tail`","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p><code>reduce</code> can be seen as a special case of <code>fold</code> with the start value of <code>head</code> folded over <code>tail</code></p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142660_1572043450","id":"20180321-064631_548930418","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1219"},{"text":"def my_reduce(seq:Seq[Int])(fn:(Int,Int) => Int) = {\n    seq.tail.fold(seq.head)(fn)\n}\n\nmy_reduce(range)(_ + _)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nmy_reduce: (seq: Seq[Int])(fn: (Int, Int) => Int)Int\n\nres149: Int = 500500\n"}]},"apps":[],"jobName":"paragraph_1542613142661_1571658701","id":"20180321-064500_498037097","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1220"},{"text":"%md\n## 3.2 foldLeft\n\nA more powerful and flexible variant of aggregation is `foldLeft`. Both `reduce` and `fold` actually require that the aggragted value has the same type as the elements in a collection. Often this is a severe limitation. In these situations `foldLeft` comes to the resuce which offers a more flexible interface.\n\nFor example if we wanted to calculate the average value of some sequence of numbers, we need to aggregate both the sum of all elements and the count. This is done in the next example, where we use a tuple as the aggregation state with the first entry being the sum and the second entry being the count.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>3.2 foldLeft</h2>\n<p>A more powerful and flexible variant of aggregation is <code>foldLeft</code>. Both <code>reduce</code> and <code>fold</code> actually require that the aggragted value has the same type as the elements in a collection. Often this is a severe limitation. In these situations <code>foldLeft</code> comes to the resuce which offers a more flexible interface.</p>\n<p>For example if we wanted to calculate the average value of some sequence of numbers, we need to aggregate both the sum of all elements and the count. This is done in the next example, where we use a tuple as the aggregation state with the first entry being the sum and the second entry being the count.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142662_1572812948","id":"20180321-064905_1449105546","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1221"},{"text":"def reduce(agg:(Int,Int), value:Int) = (agg._1 + value, agg._2 + 1)\nval zero = (0,0)\n\nval agg = range.foldLeft(zero)(reduce)\nval avg = agg._1.toFloat / agg._2.toFloat","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nreduce: (agg: (Int, Int), value: Int)(Int, Int)\n\nzero: (Int, Int) = (0,0)\n\nagg: (Int, Int) = (500500,1000)\n\navg: Float = 500.5\n"}]},"apps":[],"jobName":"paragraph_1542613142663_1572428199","id":"20160619-083947_980207953","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1222"},{"text":"val agg = range.foldLeft((0,0)) { (agg,value) => (agg._1 + value, agg._2 + 1) }\nval avg = agg._1.toFloat / agg._2.toFloat","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nagg: (Int, Int) = (500500,1000)\n\navg: Float = 500.5\n"}]},"apps":[],"jobName":"paragraph_1542613142671_1579738428","id":"20160619-084024_1949885029","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1223"},{"text":"%md\n## 3.3 aggregate\n\nIn addition to `foldLeft` there is also the even more tweakable method `aggregate` which is tweaked for possibly parallel implementation. In this scenario we have to imagine that the whole range of elements is split up into multiple subranges. Each subrange will be worked on in parallel and will return a partial result. In order to combine all partial results we need to specify an additional function.\n\nIn our example, we need to specify a function which takes two tuples (the partial results of the parallel aggregations) and combines them into a new (possibly still partial) result.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>3.3 aggregate</h2>\n<p>In addition to <code>foldLeft</code> there is also the even more tweakable method <code>aggregate</code> which is tweaked for possibly parallel implementation. In this scenario we have to imagine that the whole range of elements is split up into multiple subranges. Each subrange will be worked on in parallel and will return a partial result. In order to combine all partial results we need to specify an additional function.</p>\n<p>In our example, we need to specify a function which takes two tuples (the partial results of the parallel aggregations) and combines them into a new (possibly still partial) result.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142673_1580507926","id":"20180321-064928_1066868182","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1224"},{"text":"def reduce(agg:(Int,Int), value:Int) = (agg._1 + value, agg._2 + 1)\ndef combine(left:(Int,Int),right:(Int,Int)) = (left._1 + right._1 , left._2 + right._2)\nval zero = (0,0)\n\nval agg = range.aggregate(zero)(reduce, combine)\nval avg = agg._1.toFloat / agg._2.toFloat","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nreduce: (agg: (Int, Int), value: Int)(Int, Int)\n\ncombine: (left: (Int, Int), right: (Int, Int))(Int, Int)\n\nzero: (Int, Int) = (0,0)\n\nagg: (Int, Int) = (500500,1000)\n\navg: Float = 500.5\n"}]},"apps":[],"jobName":"paragraph_1542613142675_1580123177","id":"20160619-082901_1678080773","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1225"},{"text":"val agg = range.aggregate((0,0))(\n    { (agg,value) => (agg._1 + value, agg._2 + 1) },\n    { (left,right) => (left._1 + right._1 , left._2 + right._2)}\n)\nval avg = agg._1.toFloat / agg._2.toFloat","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nagg: (Int, Int) = (500500,1000)\n\navg: Float = 500.5\n"}]},"apps":[],"jobName":"paragraph_1542613142676_1578199433","id":"20160619-083615_1052040522","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1226"},{"text":"%md\n# Intermission - Approximating Pi Exercise","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>Intermission - Approximating Pi Exercise</h1>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142678_1578968931","id":"20170218-130709_806755551","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1227"},{"text":"%md\n# 4 Grouped Transformations\n\nSimilar to data processing frameworks (SQL, or of course also Spark), Scala also offers a `groupBy` method. In contrast to classical SQL, a `groupBy` does not require an aggregation. Instead it will create a Scala `Map` with the grouping expression being the key and all values for a specific key are provided as a value list for each key.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>4 Grouped Transformations</h1>\n<p>Similar to data processing frameworks (SQL, or of course also Spark), Scala also offers a <code>groupBy</code> method. In contrast to classical SQL, a <code>groupBy</code> does not require an aggregation. Instead it will create a Scala <code>Map</code> with the grouping expression being the key and all values for a specific key are provided as a value list for each key.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142679_1578584182","id":"20170218-130746_802683154","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1228"},{"text":"val g = (1 to 100) groupBy (_ % 2)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\ng: scala.collection.immutable.Map[Int,scala.collection.immutable.IndexedSeq[Int]] = Map(1 -> Vector(1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99), 0 -> Vector(2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100))\n"}]},"apps":[],"jobName":"paragraph_1542613142681_1576275688","id":"20160619-084507_1873835415","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1229"},{"text":"%md\nWhen we now want to perform an aggregation on the values, we can use a `map` or in this case a `mapValues` which allows us to transform the list of values to an aggregate. For example if we can sum up all values for each key: ","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>When we now want to perform an aggregation on the values, we can use a <code>map</code> or in this case a <code>mapValues</code> which allows us to transform the list of values to an aggregate. For example if we can sum up all values for each key:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142682_1577429935","id":"20180321-070942_979523573","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1230"},{"text":"val sums = g.mapValues(_.sum)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nsums: scala.collection.immutable.Map[Int,Int] = Map(1 -> 2500, 0 -> 2550)\n"}]},"apps":[],"jobName":"paragraph_1542613142682_1577429935","id":"20160619-084612_1149096691","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1231"},{"text":"%md\n# 5 Maps\n\nUsing `groupBy` implicitly brought us directly to Scala `Map`s. These work like C++ maps or Python dictionaries, i.e. they provide key-value pairs with access to elements via the key.\n\nA Map can be created from key-value pairs represented by tuples. Since most pairs are used as key-value pairs, Scala also offers an alternative syntax for defining pairs with an arrow `->`.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>5 Maps</h1>\n<p>Using <code>groupBy</code> implicitly brought us directly to Scala <code>Map</code>s. These work like C++ maps or Python dictionaries, i.e. they provide key-value pairs with access to elements via the key.</p>\n<p>A Map can be created from key-value pairs represented by tuples. Since most pairs are used as key-value pairs, Scala also offers an alternative syntax for defining pairs with an arrow <code>-&gt;</code>.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142683_1577045186","id":"20160619-084713_296513565","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1232"},{"text":"val personToAge = Map((\"Alice\", 23), (\"Bob\", 21))","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\npersonToAge: scala.collection.immutable.Map[String,Int] = Map(Alice -> 23, Bob -> 21)\n"}]},"apps":[],"jobName":"paragraph_1542613142684_1575121442","id":"20160619-084811_1943201975","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1233"},{"text":"val personToAge = Map(\"Alice\" -> 23, \"Bob\" -> 21)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\npersonToAge: scala.collection.immutable.Map[String,Int] = Map(Alice -> 23, Bob -> 21)\n"}]},"apps":[],"jobName":"paragraph_1542613142685_1574736693","id":"20160619-084728_1585437619","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1234"},{"text":"%md\nIt is also possible to convert a sequence of pairs to a `Map` with the method `toMap`.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>It is also possible to convert a sequence of pairs to a <code>Map</code> with the method <code>toMap</code>.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142686_1575890939","id":"20180321-071308_1622644156","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1235"},{"text":"val personToAge = Seq(\"Alice\" -> 23, \"Bob\" -> 21).toMap","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\npersonToAge: scala.collection.immutable.Map[String,Int] = Map(Alice -> 23, Bob -> 21)\n"}]},"apps":[],"jobName":"paragraph_1542613142687_1575506190","id":"20160619-084928_188432658","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1236"},{"text":"%md\n## 5.1 Modifying Maps\nAlthough a Scala `Map` is immutable, you can still add and remove elemebts, but these operations will return new maps. But be assured that internally Scala is optimized for this kind of usage, so there is no need to use mutable collections in most cases.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>5.1 Modifying Maps</h2>\n<p>Although a Scala <code>Map</code> is immutable, you can still add and remove elemebts, but these operations will return new maps. But be assured that internally Scala is optimized for this kind of usage, so there is no need to use mutable collections in most cases.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142688_1561270481","id":"20181110-173442_176278429","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1237"},{"text":"%md\nMaps can be modified by using `+` for adding new elements and `-` for removing elements. Again each operation will actually return a new `Map`, since we are still working with immutable collections.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"text","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Maps can be modified by using <code>+</code> for adding new elements and <code>-</code> for removing elements. Again each operation will actually return a new <code>Map</code>, since we are still working with immutable collections.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142689_1560885732","id":"20180321-071356_334556597","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1238"},{"text":"personToAge + (\"Eve\" -> 25) - \"Alice\"","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres150: scala.collection.immutable.Map[String,Int] = Map(Bob -> 21, Eve -> 25)\n"}]},"apps":[],"jobName":"paragraph_1542613142692_1559731486","id":"20160619-085529_1923037455","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1239"},{"text":"personToAge - \"Alice\"","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres151: scala.collection.immutable.Map[String,Int] = Map(Bob -> 21)\n"}]},"apps":[],"jobName":"paragraph_1542613142695_1560116234","id":"20160619-085716_356838640","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1240"},{"text":"%md\n## 5.2 Accessing Map Elements\n\nNot surprsingly all elements of a `Map` can be accessed via their keys. This is done again directly as if it was a function call on the map itself.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>5.2 Accessing Map Elements</h2>\n<p>Not surprsingly all elements of a <code>Map</code> can be accessed via their keys. This is done again directly as if it was a function call on the map itself.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142697_1557807741","id":"20160619-084910_1993407888","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1241"},{"text":"personToAge(\"Alice\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres152: Int = 23\n"}]},"apps":[],"jobName":"paragraph_1542613142699_1558577239","id":"20160619-084845_749470716","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1242"},{"text":"%md\nIf a key is used which is not present in the `Map`, Scala will throw a `NoSuchElementException`.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>If a key is used which is not present in the <code>Map</code>, Scala will throw a <code>NoSuchElementException</code>.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142701_1556268745","id":"20180321-071625_524598217","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1243"},{"text":"personToAge(\"Kaya\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"ERROR","msg":[{"type":"TEXT","data":"\n\n\n\n\n\njava.util.NoSuchElementException: key not found: Kaya\n  at scala.collection.MapLike$class.default(MapLike.scala:228)\n  at scala.collection.AbstractMap.default(Map.scala:59)\n  at scala.collection.MapLike$class.apply(MapLike.scala:141)\n  at scala.collection.AbstractMap.apply(Map.scala:59)\n  ... 48 elided\n"}]},"apps":[],"jobName":"paragraph_1542613142703_1557038243","id":"20160619-084853_1948397321","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1244"},{"text":"%md\nIn order to avoid handling exceptions, you can use the method `getOrElse` which allows you to specify a default value for unknown keys.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>In order to avoid handling exceptions, you can use the method <code>getOrElse</code> which allows you to specify a default value for unknown keys.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142706_1568195961","id":"20180321-071803_523076664","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1245"},{"text":"personToAge.getOrElse(\"Fred\", -1)\n","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres154: Int = -1\n"}]},"apps":[],"jobName":"paragraph_1542613142708_1565887468","id":"20180321-071820_1563934335","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1246"},{"text":"%md\nA different alternative is that you first check if a specific key exists. This can be done by using either the `contains` method or `isDefinedAt`. The later indicates that a `Map` actually can be seen as a partially defined function.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>A different alternative is that you first check if a specific key exists. This can be done by using either the <code>contains</code> method or <code>isDefinedAt</code>. The later indicates that a <code>Map</code> actually can be seen as a partially defined function.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142710_1566656966","id":"20180321-071909_839116483","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1247"},{"text":"personToAge.isDefinedAt(\"Fred\")\npersonToAge.isDefinedAt(\"Alice\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres155: Boolean = false\n\nres156: Boolean = true\n"}]},"apps":[],"jobName":"paragraph_1542613142713_1563963723","id":"20180321-071932_1437871070","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1248"},{"text":"personToAge.contains(\"Fred\")\npersonToAge.contains(\"Alice\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres157: Boolean = false\n\nres158: Boolean = true\n"}]},"apps":[],"jobName":"paragraph_1542613142716_1562809477","id":"20180321-071956_1695134652","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1249"},{"text":"%md\nYou can also directly access the list of all keys and values of a `Map` as a set or sequence.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>You can also directly access the list of all keys and values of a <code>Map</code> as a set or sequence.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142718_1563578975","id":"20180321-071719_1996856968","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1250"},{"text":"personToAge.values","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres159: Iterable[Int] = MapLike(23, 21)\n"}]},"apps":[],"jobName":"paragraph_1542613142719_1563194226","id":"20160619-085416_2065383526","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1251"},{"text":"personToAge.keys","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres160: Iterable[String] = Set(Alice, Bob)\n"}]},"apps":[],"jobName":"paragraph_1542613142720_1548958516","id":"20160619-085430_875058458","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1252"},{"text":"%md\n# 6 Sets\n\nA `Set` is a collection of items without duplicates. That is if you insert the same item twice or multiple equivalent items, only a single instance is stored in a set. Like Scala `List` or `Seq` collections, a `Set` also preserves the order of insertion.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>6 Sets</h1>\n<p>A <code>Set</code> is a collection of items without duplicates. That is if you insert the same item twice or multiple equivalent items, only a single instance is stored in a set. Like Scala <code>List</code> or <code>Seq</code> collections, a <code>Set</code> also preserves the order of insertion.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142720_1548958516","id":"20160619-085758_670259118","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1253"},{"text":"val persons = Set(\"Alice\", \"Fred\", \"Bob\", \"Bob\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\npersons: scala.collection.immutable.Set[String] = Set(Alice, Fred, Bob)\n"}]},"apps":[],"jobName":"paragraph_1542613142721_1548573767","id":"20160619-085810_1615137296","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1254"},{"text":"%md\nItems can be added to or removed from sets by using arithmetic operators `+` and `-`.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>Items can be added to or removed from sets by using arithmetic operators <code>+</code> and <code>-</code>.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142722_1549728014","id":"20180321-174102_92713607","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1255"},{"text":"persons + \"Eve\"","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres161: scala.collection.immutable.Set[String] = Set(Alice, Fred, Bob, Eve)\n"}]},"apps":[],"jobName":"paragraph_1542613142723_1549343265","id":"20160619-085841_590194714","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1256"},{"text":"persons + \"Bob\"","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres162: scala.collection.immutable.Set[String] = Set(Alice, Fred, Bob)\n"}]},"apps":[],"jobName":"paragraph_1542613142724_1547419521","id":"20160619-085856_1165872605","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1257"},{"text":"%md\nWhen used as a function, a `Set` simply returns `true` if an item is contained or otherwise `false`.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<p>When used as a function, a <code>Set</code> simply returns <code>true</code> if an item is contained or otherwise <code>false</code>.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142725_1547034772","id":"20180321-174022_1276577555","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1258"},{"text":"persons(\"Bob\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres163: Boolean = true\n"}]},"apps":[],"jobName":"paragraph_1542613142727_1547804270","id":"20160619-085908_2017447609","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1259"},{"text":"%md\n# 7 Special Collection: Option\n\nA Scala `Option` is a special class which is a container for one or no element. It can be used for optional values and also implements collection-like methods like `map`, `flatMap`, `filter` and some more. Although stricly speaking an `Option` is not a collection (since it does not implement corresponding traits) it can very well be used as one in many cases.\n\nThe class `Option` itself is only an abstract base class with the two specialisations `Some` and `Ǹone`. These can be used as in the following examples:","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>7 Special Collection: Option</h1>\n<p>A Scala <code>Option</code> is a special class which is a container for one or no element. It can be used for optional values and also implements collection-like methods like <code>map</code>, <code>flatMap</code>, <code>filter</code> and some more. Although stricly speaking an <code>Option</code> is not a collection (since it does not implement corresponding traits) it can very well be used as one in many cases.</p>\n<p>The class <code>Option</code> itself is only an abstract base class with the two specialisations <code>Some</code> and <code>Ǹone</code>. These can be used as in the following examples:</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142729_1545495776","id":"20160619-082436_770221513","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1260"},{"text":"val opt1 = Some(\"Eve\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nopt1: Some[String] = Some(Eve)\n"}]},"apps":[],"jobName":"paragraph_1542613142730_1546650023","id":"20160619-090315_642879708","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1261"},{"text":"val opt2 = None","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nopt2: None.type = None\n"}]},"apps":[],"jobName":"paragraph_1542613142731_1546265274","id":"20160619-090328_151955080","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1262"},{"text":"%md\n## 7.1 Use Case: Maps\nOptions naturally arise whenever operations might not return a valid value. For example a Scala `Map` cannot return a value for an unknown key. In this sitaution an `Option` is used with the `get` method to encapsulate the information if the desired key was found or not.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>7.1 Use Case: Maps</h2>\n<p>Options naturally arise whenever operations might not return a valid value. For example a Scala <code>Map</code> cannot return a value for an unknown key. In this sitaution an <code>Option</code> is used with the <code>get</code> method to encapsulate the information if the desired key was found or not.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142734_1545111027","id":"20160619-090212_1678245223","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1263"},{"text":"val personToAge = Map((\"Alice\", 23), (\"Bob\", 21))\n\npersonToAge.get(\"Alice\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\npersonToAge: scala.collection.immutable.Map[String,Int] = Map(Alice -> 23, Bob -> 21)\n\nres1: Option[Int] = Some(23)\n"}]},"apps":[],"jobName":"paragraph_1542613142735_1544726278","id":"20160619-090021_1681308095","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1264"},{"text":"personToAge.get(\"Eve\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres165: Option[Int] = None\n"}]},"apps":[],"jobName":"paragraph_1542613142737_1554729750","id":"20160619-090116_1093437267","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1265"},{"text":"personToAge.get(\"Alice\").getOrElse(-1)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres166: Int = 23\n"}]},"apps":[],"jobName":"paragraph_1542613142739_1555499248","id":"20160619-090123_45683133","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1266"},{"text":"personToAge.get(\"Eve\").getOrElse(-1)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres167: Int = -1\n"}]},"apps":[],"jobName":"paragraph_1542613142741_1553190754","id":"20160619-090146_1418376021","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1267"},{"text":"%md\n## 7.2 Using Collection methods wih Options\nAlthough technically speaking, `Option`s are not Scala collections, they provide lots of similar functionality. By making clever use of these methods, complicated chains of if/then clauses can be replaced by a flow of transformations.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>7.2 Using Collection methods wih Options</h2>\n<p>Although technically speaking, <code>Option</code>s are not Scala collections, they provide lots of similar functionality. By making clever use of these methods, complicated chains of if/then clauses can be replaced by a flow of transformations.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142743_1553960252","id":"20181112-170901_63455272","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1268"},{"text":"personToAge.get(\"Eve\").foreach(age => println(s\"$age\"))","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1542613142746_1552806005","id":"20170130-092138_495384102","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1269"},{"text":"personToAge.get(\"Bob\").foreach(age => println(s\"$age\"))","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"21\n"}]},"apps":[],"jobName":"paragraph_1542613142747_1552421256","id":"20181112-170728_65304967","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1270"},{"text":"%md\n#### Using map methods\n\nAs noted above, `Option` classes also implement `map` and `flatMap` methods, which also support elegant chaining of multiple operations without explicitly checking if the `Option` contains a value or not.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h4>Using map methods</h4>\n<p>As noted above, <code>Option</code> classes also implement <code>map</code> and <code>flatMap</code> methods, which also support elegant chaining of multiple operations without explicitly checking if the <code>Option</code> contains a value or not.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142749_1550112763","id":"20160619-091243_2127254258","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1271"},{"text":"half(2).map(_ * 2)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres172: Option[Int] = Some(2)\n"}]},"apps":[],"jobName":"paragraph_1542613142750_1551267010","id":"20160619-091303_2058151772","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1272"},{"text":"half(2).map(_*3).filter(_ % 2 == 0).map(_ / 2)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres173: Option[Int] = None\n"}]},"apps":[],"jobName":"paragraph_1542613142751_1550882261","id":"20160619-091317_1239401787","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1273"},{"text":"%md\n#### Using flatMap with Options\n\nWhen Options are created inside sequence transformations, using `flatMap` will automatically unpack all options which contain some values. Let us look at the following example where a method returns an option and is used for transforming elements of a number range. ","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h4>Using flatMap with Options</h4>\n<p>When Options are created inside sequence transformations, using <code>flatMap</code> will automatically unpack all options which contain some values. Let us look at the following example where a method returns an option and is used for transforming elements of a number range.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142752_1536646552","id":"20160619-090336_141233239","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1274"},{"text":"def half(i:Int) = i match { \n    case i:Int if i%2 == 0 => Some(i/2) \n    case _ => None \n}","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nhalf: (i: Int)Option[Int]\n"}]},"apps":[],"jobName":"paragraph_1542613142754_1537416049","id":"20160619-090358_2042231414","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1275"},{"text":"(1 to 10).flatMap(half)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres171: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3, 4, 5)\n"}]},"apps":[],"jobName":"paragraph_1542613142755_1537031300","id":"20160619-090932_847593596","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1276"},{"text":"%md\n### Convert to Sequence\nNaturally an `Option` can also be converted to a Scala sequence - either a one-element sequence or an empty sequence.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Convert to Sequence</h3>\n<p>Naturally an <code>Option</code> can also be converted to a Scala sequence - either a one-element sequence or an empty sequence.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142757_1534722807","id":"20180321-180011_1879158698","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1277"},{"text":"half(2).toSeq","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres174: Seq[Int] = List(1)\n"}]},"apps":[],"jobName":"paragraph_1542613142760_1533568560","id":"20160619-091349_1520570793","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1278"},{"text":"%md\n## 7.3 Using pattern matching with `Option`s\n\nA Scala `Option` is a perfect candidate to use in pattern matching, like in the following example.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{"language":"markdown","editOnDblClick":true},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>7.3 Using pattern matching with <code>Option</code>s</h2>\n<p>A Scala <code>Option</code> is a perfect candidate to use in pattern matching, like in the following example.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142762_1534338058","id":"20180321-175302_1744265196","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1279"},{"text":"def printAge(name:String) = {\n    personToAge.get(name) match {\n        case Some(age) => println(s\"Age of $name is $age\")\n        case None => println(s\"Don't know $name\")\n    }\n}\n\nprintAge(\"Alice\")\nprintAge(\"Eve\")","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nprintAge: (name: String)Unit\nAge of Alice is 23\nDon't know Eve\n"}]},"apps":[],"jobName":"paragraph_1542613142765_1531644816","id":"20170130-092108_1927839560","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1280"},{"text":"%md\n# 8 Mutable Collections\n\nSo far we have been using immutable collections, i.e. collections where each modification would return a new collection. But sometimes we want to work with mutable collections. This is particularily useful when building new collections.","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h1>8 Mutable Collections</h1>\n<p>So far we have been using immutable collections, i.e. collections where each modification would return a new collection. But sometimes we want to work with mutable collections. This is particularily useful when building new collections.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142767_1532414314","id":"20160619-065047_1358513749","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1281"},{"text":"%md\n## 8.1 Arrays, Lists and Sequences","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>8.1 Arrays, Lists and Sequences</h2>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142769_1542417785","id":"20160619-092316_141616051","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1282"},{"text":"import scala.collection.mutable\n\nval seq = mutable.Seq(1,2,3)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nimport scala.collection.mutable\n\nseq: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)\n"}]},"apps":[],"jobName":"paragraph_1542613142772_1541263538","id":"20160619-091948_526877963","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1283"},{"text":"val list = mutable.ListBuffer(1,2,3)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nlist: scala.collection.mutable.ListBuffer[Int] = ListBuffer(1, 2, 3)\n"}]},"apps":[],"jobName":"paragraph_1542613142774_1542033036","id":"20160619-092036_1336595769","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1284"},{"text":"list += 5","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres175: list.type = ListBuffer(1, 2, 3, 5)\n"}]},"apps":[],"jobName":"paragraph_1542613142776_1539724543","id":"20160619-092107_1912931938","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1285"},{"text":"list -= 3","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres176: list.type = ListBuffer(1, 2, 5)\n"}]},"apps":[],"jobName":"paragraph_1542613142777_1539339794","id":"20160619-092127_1888393889","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1286"},{"text":"list.toList","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres177: List[Int] = List(1, 2, 5)\n"}]},"apps":[],"jobName":"paragraph_1542613142779_1540109292","id":"20160619-092718_488020296","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1287"},{"text":"%md\n## 8.2 Maps","dateUpdated":"2018-11-19T07:39:02+0000","config":{"tableHide":false,"editorSetting":{},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>8.2 Maps</h2>\n</div>"}]},"apps":[],"jobName":"paragraph_1542613142780_1538185547","id":"20160619-092337_562470896","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1288"},{"text":"val map = mutable.Map(\"Alice\" -> 23, \"Bob\" -> 41)","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nmap: scala.collection.mutable.Map[String,Int] = Map(Bob -> 41, Alice -> 23)\n"}]},"apps":[],"jobName":"paragraph_1542613142781_1537800798","id":"20160619-092158_1004036203","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1289"},{"text":"map(\"Alice\") = 24\nmap","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres179: scala.collection.mutable.Map[String,Int] = Map(Bob -> 41, Alice -> 24)\n"}]},"apps":[],"jobName":"paragraph_1542613142782_1538955045","id":"20160619-092230_1816095361","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1290"},{"text":"map(\"Eve\") = 32\nmap","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres181: scala.collection.mutable.Map[String,Int] = Map(Bob -> 41, Eve -> 32, Alice -> 24)\n"}]},"apps":[],"jobName":"paragraph_1542613142783_1538570296","id":"20160619-092249_1407841305","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1291"},{"text":"map.toMap","dateUpdated":"2018-11-19T07:39:02+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"\nres182: scala.collection.immutable.Map[String,Int] = Map(Bob -> 41, Eve -> 32, Alice -> 24)\n"}]},"apps":[],"jobName":"paragraph_1542613142784_1622830305","id":"20160619-092353_510007708","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1292"},{"text":"","dateUpdated":"2018-11-19T07:39:02+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","results":[],"enabled":true,"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1542613142785_1622445556","id":"20160619-072503_1507655032","dateCreated":"2018-11-19T07:39:02+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1293"}],"name":"Scala Introduction - Part 2 - Collections - Full","id":"2DWE42FVU","angularObjects":{"2D8DSN3N4:shared_process":[],"2D7W55G1J:shared_process":[],"2DA3X6UGN:shared_process":[],"2D9HTU14T:shared_process":[],"2DBA6X8JB:shared_process":[],"2DBSCZXK2:shared_process":[],"2D9M853BP:shared_process":[],"2DAXFQ4X2:shared_process":[],"2DB3TEGGU:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}